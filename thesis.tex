\documentclass[12pt, openany]{memoir}

\usepackage{latexsym,amsmath,amsfonts,amssymb,amsthm}
\usepackage{url}
\usepackage{proof}
\usepackage[style=alphabetic,natbib=true,backend=biber,maxbibnames=99]{biblatex}
\usepackage[colorlinks=true]{hyperref}
\usepackage[nameinlink,capitalize,noabbrev]{cleveref}
\usepackage{graphicx}
\RequirePackage[T1]{fontenc}
\RequirePackage[tt=false,type1=true]{libertine}
\RequirePackage[varqu]{zi4}
\RequirePackage[libertine]{newtxmath}
\usepackage{microtype}
\usepackage{cmutr}
\usepackage{epass}
\usepackage{minted}
\usepackage{graphicx}
\usepackage{tikz}
\usepackage{wasysym}
\usepackage{mathpartir}
\usepackage{stmaryrd} 
\usepackage{braket}
\usepackage{subcaption}
\usepackage{hyperref}

\setlrmarginsandblock{1.25in}{*}{1}
\setulmarginsandblock{1.5in}{*}{1}
\setheaderspaces{*}{2\onelineskip}{*}
\checkandfixthelayout

\newcommand*{\pare}[0]{\mathbin{\bindnasrepma}}
\newcommand*{\send}[2]{\textbf{send}\ #1\ #2}
\newcommand*{\recv}[2]{\textbf{recv}\ #1\ #2}
\newcommand*{\call}[3]{\textbf{call}\ #1\ (#2)\ [#3]}
\newcommand*{\fwd}[2]{\textbf{fwd}\ #1\ #2}
\newcommand*{\cancel}[1]{#1 \lightning}
\newcommand*{\craise}[1]{\textbf{raise}\ #1}
\newcommand*{\trycatch}[3]{#3 \twoheadleftarrow	\textbf{try}\ #1(#3)\ \textbf{catch}\ #2(#3)}
\newcommand*{\spawn}[3]{#3 \leftarrow #1(#3);\ #2(#3)}
\newcommand*{\judge}[4]{#1 \vdash #2 :: #3; #4}
\newcommand*{\procObj}[4]{\textbf{proc}(#1/#2/#3/#4)}
\newcommand*{\config}[0]{\mathcal{C}}
\newcommand*{\cancelSet}[0]{\mathcal{S}}

\lstset{style=verb, language=epass, numbers=none}

% Check out the memoir manual for other chapter styles.
\chapterstyle{default}

\setsecnumdepth{subsection}

\nouppercaseheads
\makepagestyle{nonumbers}
\createmark{chapter}{left}{nonumber}{}{}
\createmark{section}{right}{nonumber}{}{}
\makeevenhead{nonumbers}{\thepage\qquad{\itshape\leftmark}}{}{}
\makeoddhead{nonumbers}{}{}{{\itshape\rightmark}\qquad\thepage}

\addbibresource{bibliography.bib}


\input{infrastructure.tex}

\begin{document}

\frontmatter

\pagestyle{empty}

\title{\textbf{Exceptions in a Message Passing Interpretation of Substructural Logic}}
\author{Shengchao Yang}

\keywords{Exceptions, Affine Logic, Session Types, Concurrent communication}

\maketitle

\pagestyle{nonumbers}

\begin{abstract}
  Session types are used to describe the structure of communications across channels. Previous research has established a message-passing interpretation of intuitionistic linear logic. 
  Meanwhile, communication failures have been an important research topic in session types. 
  However, the exception handling mechanism has not been well studied in the context of message passing. 
  To bridge this gap, we studied the interpretation of classical affine logic and proposed a new type system containing features such as explicit channel cancellation and exception handling constructors. 
  Our type system ensures program correctness by enforcing session fidelity and deadlock freedom. 
  To experiment, we implemented an interpreter for our language and tested it on several examples to match the expected process behavior. 
  Additionally, we explore the possibility of representing some programming features, such as non-exhaustive matches, in our language using the exception mechanism.
\end{abstract}

\chapter{Acknowledgements}

TBD

\cleardoublepage
\tableofcontents

\mainmatter

\chapter{Introduction}

Linear logic is a refinement of intuitionistic logic that does not satisfy weakening and contraction. 
It emphasizes the management of resources, where each formula should be used exactly once. 
Informally speaking, the assumption cannot be too strong for the conclusion, such as $A, B \vdash B$.
The Curry-Howard isomorphism states a correspondence between logical proof theory and computational type theory \cite{Howard1980}.
The computational interpretation of linear logic, firstly given by Abramsky, lays the foundation for the connection between $\pi$-calculus and linear logic \cite{Abramsky1933}. 
Later on, an expressive formulation of intuitionistic linear logic provides a correspondence between linear proofs and processes, 
which gives rise to two important ideas: proofs as processes and cut as computation \cite{Caires2014}.

On the other hand, exceptions have been a practical topic during the development of programming languages.
Programmers can utilize exceptions to write explicit control flow for their code. In most functional programming languages, exceptions are managed by expression constructors. 
For instance, in Standard ML, exceptions are raised by the keyword \texttt{raise} and caught by the keyword \texttt{handle} \cite{Milner1997}. 
In concurrent models, communication failures remain both inevitable and critical. 
Previous research applies affine session types that relax the linearity of session types to incorporate error handling \cite{Mos2014}.

Given the relationship between linear propositions and session types, our goal is to implement exceptions under the computational interpretation of linear logic.
However, exceptions are inherently incompatible with linear logic. 
Let us assume we have some kind of exception handler where part of its processes are designated to deal with exceptional situations. 
In other words, it will be activated if an exception is raised. 
This violates linearity, as the resources allocated for the exception handler will not be utilized if no exceptions occur. 
Affinity, on the other hand, allows us to model such behavior, where resources that are not used can be weakened.

Our solution works under affine systems due to the nature of exceptions explained above. 
Weakening provides a way to discard resources that are not used, and we interpret this structural rule as a process $\texttt{cancel}$ to cancel a channel. 
We add two new constructors to the type system: $\texttt{raise}$ and $\texttt{try}\ \texttt{catch}$. 
Although these constructors look similar to most exception handling mechanisms in programming languages, 
they are interpreted as processes, where the first signals an exception during the computation of processes,
and the second catches the signal and activates an additional process that handles the exception concurrently.

We briefly summarize the outline and contributions of this thesis.
In the rest of Chapter $1$, we will introduce the correlation between sequent proofs and processes, classical affine logic, and exceptions in functional programming languages.
Chapter $2$ will present the new type system we propose that deals with exceptions and its statics.
Computation steps and meta theories that ensures safety of our type system will be formalized and proved in Chapter $3$. 
In Chapter 4, we will demonstrate the implementation of the language interpreter and provide examples of traced processes.
Finally, Chapter $5$ will show how to represent non-exhaustive matches under our type system, with commentary on related work, limitations of the current approach, and avenues for future research.
\section{Proofs as processes} 
A sequent proof of a proposition provides its computational meaning.
We use proof terms to record the structure of proofs such that we can reconstruct the proof by its proof term.
In the context of intuitionistic linear logic, the proof term corresponds to a process. 
Below is an annotated sequent proof in intuitionistic linear logic.
\[
  x_1 : A_1, x_2 : A_2, \ldots, x_n : A_n \vdash P :: c : C
\]
where variables $x_1, x_2, \ldots, x_n, c$ represents distinct channels, propositions $A_1, A_2, \ldots, C$ represents session types, 
and annotation $x_i : A_i$ means the messages send along channel $x_i$ must obey the communication behavior specified by $A_i$.
Under such setting, we can regard the sequent as a process $P$ that uses all the channels in the antecedent and provides a channel in the succedent.

In proof theory, the cut allows for a composition of two separate proofs into a single proof, and correspondingly, a parallel composition of two processes connected by a channel.
\[
  \infer[\text{cut}_A]{\Gamma, \Gamma' \vdash P \mid Q :: c : C}{
    \Gamma \vdash P :: x : A
    &
    \Gamma', x : A \vdash Q :: c : C
  }
\]

The left premise represents a process $P$ that provides channel $x$, and the right premise represents another process $Q$ that uses channel $x$. 
In other words, the cut process $P$ communicates with process $Q$ through channel $x$ specified by $A$. 
The linearity of propositions ensures that the channel $x$ has only two endpoints, 
and other processes besides $P$ and $Q$ will not have access to channel $x$, 
since every channel has a distinct variable name.

The cut rule can also be understood as the spawning of a new process. 
The main thread spawns a new process $P$, splits the current resources, creates a new channel $x$,
assigns it as process $P$'s endpoint, and continues to execute the rest of the process $Q$ with the remaining resources in parallel.
\section{Classical linear logic} \label{sec:cll}
In classical logic, the judgement has the following form.
\[
  A_1, A_2, \ldots, A_n \vdash C_1, C_2, \ldots, C_m
\]
which means the conjunction of antecedents $\bigwedge_{i = 1}^n A_i$ implies the disjunction of the succedents $\bigvee_{j = 1}^m C_j$.
The negation of a proposition becomes a new primitive connective in classical logic, which distinct from intuitionistic logic where $\neg A$ is as same as $A \supset \bot$.
\[
  \infer[\text{negL}]{\Gamma, \neg A \vdash \Delta}{\Gamma \vdash A, \Delta}
  \qquad
  \infer[\text{negR}]{\Gamma \vdash \neg A, \Delta}{\Gamma, A \vdash \Delta}
\]
The behavior of negation flips around the proposition between the antecedent and the succedent. 
In other words, it assumes the contrary and tries to derive a contradiction.

Previous research has shown that classical linear logic can be viewed as $\pi$-calculus
by interpreting the negation as a dual operation on session types \cite{Wadler2012}. 
Defining the dual of a session type $A$ is $A^{\bot}$, we can rewrite the above the judgement in a single-sided form.
\[
  \vdash A_1^\bot, A_2^\bot, \ldots, A_n^\bot, C_1, C_2, \ldots, C_m
\]
Instead of cutting a proposition on different sides of inference, we cut a proposition against its dual.
\[
  \infer[\text{cut}_A]{\vdash \Delta, \Delta'}{
    \vdash A, \Delta
    &
    \vdash A^\bot, \Delta'
  }
\]
In classical logic, we know a proposition $A$ is either true or its dual proposition $A^\bot$ is true.
In the above cut rule, we can eliminate the usage of $A$ by connecting the remaining context using disjunction. 

Under the interpretation of proofs as processes, we can write the annotated two-sided judgement as follows.
\[
  x_1 : A_1, x_2 : A_2, \ldots, x_n : A_n \vdash P :: y_1 : C_1, y_2 : C_2, \ldots, y_m : C_m
\]
This judgement can be viewed as a process $P$ that communicates along channels $x_1, x_2, \ldots, x_n$
and $y_1, y_2, \ldots, y_m$, where each channel obeys its protocol requirements.
We do not distinguish whether a channel is used or provided, because we can always use the negation rule to flip the propositions.
In other word, classical logic blurs the distinction between client and server roles in concurrent communication.
It is possible to demonstrate the safety of this system by converting it back to intuitionistic linear logic through double negation translation \cite{Friedman1978}.
Such translation has practical applications, such as continuation passing style translation.
\section{Affine logic}
Affine logic is a substructural logic that rejects the structural rule of contraction. 
In other words, it is a form of linear logic that retains the weakening rule. 
There are two ways of formalizing weakening rules. 
The first formulation is implicit weakening, which modifies the original rules, 
such as the identity rule, to allow for the closure of the proof by silently discarding all propositions in the context.
\[
  \infer[\textbf{1}R]{\Gamma \vdash \textbf{1}}{}
  \qquad
  \infer[\text{identity}]{\Gamma, A \vdash A}{}
\]
Another formulation adds the explicit weakening rules.
\[
  \infer[\text{weaken}]{\Gamma, A \vdash C}{\Gamma \vdash C}
\]
Under the classical setting, we will have two weakening rules, one for the antecedent and another one for the succedent.
We can establish the equivalence of these two formulations. 
However, concerning the computational interpretation, the explicit formulation holds greater favorability for two reasons.
Firstly, it offers explicit resource control for programmers. 
Let us annotate the explicit weakening rule as follows.
\[
  \infer[\text{weaken}]{\Gamma, x : A \vdash c : C}{
    \deduce{\Gamma \vdash c : C}{P}
  }
\]
We can interpret this rule as a process that discards the future usage of channel $x$ from resources and proceeds with process $P$. 
Discarding resources is a common practice in programming. For example, below is an implementation of a function that returns the length of a list.
\inputminted{ocaml}{code/length.ml}
In the inductive case where the list is not empty, the function discards the head of the list and proceeds with the remain list.
If we enforce linearity in this function, we will have to do unnecessary operations to use the element of the list, which is not appropriate.

Besides the usage of dropping resources, static checking for the interpreter does not align well with implicit weakening. 
According to implicit rule, when the process reaches its end, all channels in the context will be discarded. 
This fails to verify whether the programmer intentionally or accidentally left some resources unused.

\chapter{Type system}
\section{Propositions} \label{sec:propsyntax}
The syntax of the propositions are defined in \cref{fig:propositions}.
\begin{figure}[H]
  \centering
  \begin{tabular}{c r l l}
    Propositions\ $A, B$ & $::=$ & $\textbf{1}$ & 'One', nullary case of $\otimes$ \\ 
    & $\mid$ & $\boldsymbol{\bot}$ & 'Bottom', nullary case of $\pare$  \\
    & $\mid$ & $A \otimes B$ & 'Tensor', communicates with $A$ and behaves as $B$  \\  
    & $\mid$ & $A \pare B$ & 'Par', communicates with $A$ and behaves as $B$ \\    
    & $\mid$ & $\& \{l : A_l\}_{l \in L}$ & 'With', $n-$ary choices distinguished by labels $l$ \\
    & $\mid$ & $\oplus \{l : A_l\}_{l \in L}$ & 'Plus', $n-$ary choices distinguished by labels $l$ 
   \end{tabular}
  \caption{Syntax of propositions}
  \label{fig:propositions}
\end{figure}
\begin{figure}[H]
  \centering
  \begin{tabular}{r c l l}
    $(A)^\bot$ & $\longrightarrow$ & $A^\bot$ & $A$ atom \\ 
    $\textbf{1}^\bot$ & $\longrightarrow$ & $\boldsymbol{\bot}$ & \\
    $\boldsymbol{\bot} ^ \bot$ & $\longrightarrow$ & $\textbf{1}$ & \\
    $(A \otimes B)^\bot$ & $\longrightarrow$ & $A^\bot\pare B^\bot$ &  \\  
    $(A \pare B)^\bot$ & $\longrightarrow$ & $A^\bot \otimes B^\bot$ & \\    
    $(\oplus\{l : A_l\}_{l \in L})^\bot$ & $\longrightarrow$ & $\& \{l : A_l^\bot\}_{l \in L}$ & \\ 
    $(\&\{l : A_l\}_{l \in L})^\bot$ & $\longrightarrow$ & $\oplus \{l : A_l^\bot\}_{l \in L}$ & \\
   \end{tabular}
  \caption{Dual operations on propositions}
  \label{fig:dual}
\end{figure}
The propositions can be classified into two categories: multiplicatives ($\otimes, \pare$) and additives ($\oplus, \&$).
The behavior of each type based on whether it is in the antecedent or the succedent of a sequent.
Because of the dual operation in classical logic mentioned in \cref{fig:dual}, the behavior of a session type in antecedent is as same as its dual in the succedent and vice versa.
It is worth noticing that taking the dual of a proposition twice will result in the original proposition, i.e. ${(A^\bot)}^\bot = A$.

To simply the explanation of the propositions, we discuss its logical behavior of each proposition in the succedent
through its inference right rule.
\begin{itemize}
  \item One
  \[
    \infer[\textbf{1}R]{\cdot \vdash \textbf{1}}{}
  \]
  The empty truth, called One, holds only if there are no resources. 
  This is the nullary case of the multiplicative conjunction.
  \item Bottom
  \[
    \infer[\boldsymbol{\bot} R]{\Gamma \vdash \boldsymbol{\bot}, \Delta}{
      \Gamma \vdash \Delta
    }
  \]
  Bottom is a nullary case of the multiplicative disjunction.
  This proposition does not contain any resources and can be dropped freely.
  \item Tensor
  \[
    \infer[\otimes R]{\Gamma_1, \Gamma_2 \vdash A \otimes B, \Delta_1, \Delta_2}{
      \Gamma_1 \vdash A, \Delta_1
      &
      \Gamma_2 \vdash B, \Delta_2
    }
  \]
  The multiplicative conjunction $A \otimes B$ is true if $A$ and $B$ are both true.
  We need to subdivide the resources, use some of them to prove $A$ the other to prove $B$. 
  \item Par
  \[
    \infer[\pare R]{\Gamma \vdash A \pare B, \Delta}{
      \Gamma \vdash A, B, \Delta
    }
  \]
  The multiplicative disjunction $A \pare B$ is true if given a refutation of $A$, $B$ is true,
  or given a refutation of $B$, $A$ is true in the current context.
  \item With
  \[
    \infer[\& R]{\Gamma \vdash \&\{l : A_l\}_{l \in L}, \Delta}{
      \Gamma \vdash A_l, \Delta
      &
      \forall l \in L
    }
  \]
  The additive conjunction $\&\{l : A_l\}_{l \in L}$ is true if for all $l \in L$, $A_l$ are true separately with the current resources.
  \item Plus
  \[
    \infer[\oplus R_k]{\Gamma \vdash \oplus\{l : A_l\}_{l \in L}, \Delta}{
      \Gamma \vdash A_k, \Delta
      &
      k \in L
    }
  \]
  The additive disjunction $\oplus\{l : A_l\}_{l \in L}$ is true if there exists some $k \in L$ such that $A_k$ is true with the current resources.
  Therefore, the number of rules is equal to the number of labels in $L$.
\end{itemize}
The linear implication $A \multimap B$ is not included in the system because it can be derived from $A^\bot \pare B$.
We can prove this equivalence. Assume $\Gamma \vdash A \multimap B$, 
by the invertibility, we have $\Gamma, A \vdash B$.
Using the dual operator, we can derive $\Gamma \vdash A^\bot, B$.
By $\pare R$, we conclude $\Gamma \vdash A \pare B$.
Since the proof is invertible, we can derive the other direction as well.

We include the inference rule of identity and cut in our system.
\[
  \infer[\text{identity}_A]{A \vdash A}{}
  \quad
  \infer[\text{cut}_A]{\Gamma_1, \Gamma_2 \vdash \Delta_1, \Delta_2}{
    \Gamma_1 \vdash A, \Delta_1
    &
    \Gamma_2, A \vdash \Delta_2
  }
\]
The identity rule closes the proof by ensuring that there is only one same proposition on each side of the sequent.
The cut rule allows us to split the context to prove some arbitrary propositions $A$ and then combine the results to prove the conclusion with the remaining context.

The structural rule of weakening is included in the system. Since we are working with a two-sided sequent, 
we have weakening rules for both the antecedent and the succedent.
\[
  \infer[\text{weaken}L]{
    \Gamma, A \vdash \Delta
  }{
    \Gamma \vdash \Delta
  }
  \quad
  \infer[\text{weaken}R]{
    \Gamma \vdash A, \Delta
  }{
    \Gamma \vdash \Delta
  }
\]

To avoid arbitrary splitting of the context and extra premises, we modify the $\otimes R$ as the following:
\[
  \infer[\otimes R^*]{\Gamma, A \vdash A \otimes B, \Delta}{
    \Gamma \vdash B, \Delta
  }
\]
To prove this rule sensible in the original logical system, we need to show that the original $\otimes R$ can be derived from $\otimes R^*$ and vice versa.
\begin{itemize}
  \item Assume we have a derivation $\mathcal{D}_1$ for $\Gamma_1 \vdash A, \Delta_1$ and $\mathcal{D}_2$ for $\Gamma_2 \vdash B, \Delta_2$.
  We can create a derivation for $\Gamma_1, \Gamma_2 \vdash A \otimes B, \Delta_1, \Delta_2$ without using $\otimes R$ rule as the following:
  \[
    \infer[\text{cut}_A]{\Gamma_1, \Gamma_2 \vdash A \otimes B, \Delta_1, \Delta_2}{
      \deduce{\Gamma_1 \vdash A, \Delta_1}{\mathcal{D}_1}
      &
      \infer[\otimes R^*]{\Gamma_2, A \vdash A \otimes B, \Delta_2}{
        \deduce{\Gamma_2 \vdash B, \Delta_2}{\mathcal{D}_2}
      }
    }
  \]
  \item Assume we have a derivation $\mathcal{D}$ for $\Gamma \vdash B, \Delta$.
  We can create a derivation for $\Gamma, A \vdash A \otimes B, \Delta$ without using $\otimes R^*$ rule as the following:
  \[
    \infer[\otimes R]{\Gamma, A \vdash A \otimes B, \Delta}{
      \infer[\text{identity}_A]{A \vdash A}{}
      &
      \deduce{\Gamma \vdash B, \Delta}{\mathcal{D}}
    }
  \]
\end{itemize}
We can rewrite $\pare L^*$ rule accordingly and justify its equivalence with the original $\pare L$. 
\[
  \infer[\pare L^*]{\Gamma, A \pare B \vdash A, \Delta}{
    \Gamma \vdash B, \Delta
  }
\]
\section{Processes}
In this section, we will annotate the proofs with proof terms as interpret them as processes.
Moreover, we will introduce our exception handling mechanism in our system. 
We first present the syntax of the processes in \cref{fig:processes}.
\begin{figure}[H]
  \centering
  \begin{tabular}{r r r l}
    Messages & $M$ & $::=$ & $()$ \\
    & & $\mid$ & $l$ \\
    & & $\mid$ & $x$ \\  
    Continuations & $K$ & $::=$ & $(() \Rightarrow P)$ \\    
    & & $\mid$ & $(l \Rightarrow P_l)_{l \in L}$ \\
    & & $\mid$ & $(x \Rightarrow P(x))$ \\
    Processes & $P, Q$ & $::=$ & $\send{x}{M}$ \\
    & & $\mid$ & $\recv{x}{K}$ \\
    & & $\mid$ & $\fwd{y}{x}$ \\
    & & $\mid$ & $\cancel{x}$ \\
    & & $\mid$ & $\spawn{P}{Q}{x}$ \\
    & & $\mid$ & $\craise{M}$ \\
    & & $\mid$ & $\trycatch{P}{Q}{x}$ \\
    & & $\mid$ & $\cdot$ \\
    & & $\mid$ & $P; Q$
   \end{tabular}
  \caption{Syntax of processes}
  \label{fig:processes}
\end{figure}
We separate the terms into three categories: messages, continuations, and processes. 
We use variables to represent channels and strings to represent labels. 
We require the channels to have distinct names. 
The information passed through channels is called messages, which can be either a unit message $()$, a label $l$, or a channel $x$. 
The continuation specifies the behavior of the process after receiving a message. 
Correspondingly, there are three kinds of continuations. $(() \Rightarrow P)$ is a unit continuation that waits for a unit message and continues with process $P$. 
$(l \Rightarrow P_l)_{l \in L}$ is a branching continuation that selects to execute process $P_l$ based on the label $l$ it receives. 
In other words, it has prepared the same number of processes as the number of labels in $L$. $(x \Rightarrow P(x))$ is a continuation that waits for a channel $x$ and continues with process $P(x)$. 
We write $P(x)$ instead of $P$ to indicate that the process $P$ depends on the channel $x$.

From the description above, we provide an intuition of how processes interact with each other. 
Imagine a segment where one endpoint outputs a message and passes it to the other endpoint, 
which works as a continuation that waits for the message through this segment. 
We can see that each message has its own corresponding continuation. 
This means that if the message passing through the segment is a label while the continuation is waiting for a channel, 
the interaction will be stuck and cannot proceed. 
We can use propositions as session types introduced in \cref{sec:propsyntax} to restrict channel behavior. 
More details on this observation will be discussed in the operational semantics.

We present the annotated inference rules in \cref{fig:static}, where proof terms are interpreted as processes.
The judgement has the form $\judge{\Gamma}{P}{\Delta}{\Omega}$, 
which means the process $P$ communicates along the channels in $\Gamma$ and $\Delta$ and has an exception handler $\Omega$.
Such rules are also called the static semantics of the type system.

\begin{figure}
  \begin{rules}
    \defrule[\textbf{1}$R$][oneR]{}{\judge{\cdot}{\send{x}{()}}{x : \textbf{1}}{\Omega}}
    \qquad
    \defrule[\textbf{1}$L$][oneL]{\judge{\Gamma}{P}{\Delta}{\Omega}}{
      \judge{\Gamma, x : \textbf{1}}{\recv{x}{(() \Rightarrow P)}}{\Delta}{\Omega}
    }\\
    \defrule[$\boldsymbol{\bot}R$][botR]{\judge{\Gamma}{P}{\Delta}{\Omega}}{
      \judge{\Gamma}{\recv{x}{(() \Rightarrow P)}}{x : \boldsymbol{\bot}, \Delta}{\Omega}
    }
    \qquad
    \defrule[$\boldsymbol{\bot}L$][botL]{}{\judge{x : \boldsymbol{\bot}}{\send{x}{()}}{\cdot}{\Omega}}\\
    \defrule[$\otimes R^*$][tensorR]{\judge{\Gamma}{P}{x : B, \Delta}{\Omega}}{
      \judge{\Gamma, y : A}{\send{x}{y}; P}{x : A \otimes B, \Delta}{\Omega}
    }
    \qquad
    \defrule[$\otimes L$][tensorL]{\judge{\Gamma, x : B, y : A}{P}{\Delta}{\Omega}}{
      \judge{\Gamma, x : A \otimes B}{\recv{x}{(y \Rightarrow P(y))}}{\Delta}{\Omega}
    }\\
    \defrule[$\pare R$][parR]{\judge{\Gamma}{P}{\Delta}{x : B, y : A, \Omega}}{
      \judge{\Gamma}{\recv{x}{(y \Rightarrow P(y))}}{x : A \pare B, \Delta}{\Omega}
    }
    \qquad
    \defrule[$\pare L^*$][parL]{\judge{\Gamma, x : B}{P}{\Delta}{\Omega}}{
      \judge{\Gamma, x : A \pare B}{\send{x}{y}; P}{y : A, \Delta}{\Omega}
    }\\
    \defrule[$\oplus R_k$][orR]{\judge{\Gamma}{P}{A_k}{\Omega} \\ k \in L}{
      \judge{\Gamma}{\send{x}{k}; P}{x : \oplus\{l : A_l\}_{l \in L}, \Delta}{\Omega}
    }
    \quad
    \defrule[$\oplus L$][orL]{\judge{\Gamma, x : A_l}{P_l}{\Delta}{\Omega} \\ (\forall l \in L)}{
      \judge{\Gamma, x : \oplus\{l : A_l\}_{l \in L}}{\recv{x}{(l \Rightarrow P_l)_{l \in L}}}{\Delta}{\Omega}
    }\\
    \defrule[$\& R$][withR]{\judge{\Gamma, x : A_l}{P_l}{\Delta}{\Omega} \\ (\forall l \in L)}{
      \judge{\Gamma, x : \&\{l : A_l\}_{l \in L}}{\recv{x}{(l \Rightarrow P_l)_{l \in L}}}{\Delta}{\Omega}
    }
    \quad
    \defrule[$\& L_k$][withL]{\judge{\Gamma, x : A_k}{P}{\Delta}{\Omega} \\ k \in L}{
      \judge{\Gamma, x : \&\{l : A_l\}_{l \in L}}{\send{x}{k}; P}{\Delta}{\Omega}
    }\\
    \defrule[weakenR][weakenR]{\judge{\Gamma}{P}{\Delta}{\Omega}}{
      \judge{\Gamma}{\cancel{x}; P}{x : A, \Delta}{\Omega}
    }
    \qquad
    \defrule[weakenL][weakenL]{\judge{\Gamma}{P}{\Delta}{\Omega}}{
      \judge{\Gamma, x : A}{\cancel{x}; P}{\Delta}{\Omega}
    }
    \qquad
    \defrule[$\text{identity}_A$][identity]{}{
      \judge{y : A}{\fwd{x}{y}}{x : A}{\Omega}
    }
    \\
    \defrule[$\text{cut}_A$][cut]{\judge{\Gamma_1}{P(x)}{x : A, \Delta_1}{\cdot} \\ \judge{\Gamma_2, x : A}{Q(x)}{\Delta_2}{\Omega}}{
      \judge{\Gamma_1, \Gamma_2}{\spawn{P}{Q}{x}}{\Delta_1, \Delta_2}{\Omega}
    }
    \qquad
    \defrule[empty][nothing]{}{
      \judge{\cdot}{\cdot}{\cdot}{\Omega}
    }
    \\
    \defrule[raise][raise]{\judge{\Gamma}{P}{\Delta}{\cdot}}{
      \judge{\Gamma}{\craise{P}}{\Delta}{\Omega}
    }\\
    \defrule[$\text{trycatch}_A$][trycatch]{
      \judge{\Gamma_1}{P(y)}{y : A, \Delta_1}{x : \text{exn}}\\
      \judge{\Gamma_2, x : \text{exn}, y : A}{\text{erecv}\ x\ Q(y)}{\Delta_2}{\Omega}
    }{
      \judge{\Gamma_1, \Gamma_2}{\trycatch{P}{Q}{y}}{\Delta_1, \Delta_2}{\Omega}
    }
  \end{rules}
  \caption{Static semantics of the type system}
  \label{fig:static}
\end{figure} 

We first introduce the standard processes and explain how the information flows through channels. 
Processes of $\textbf{send}$ and $\textbf{recv}$ are the elementary processes. 
$\send{x}{M}$ sends a message $M$ along channel $x$, and $\recv{x}{K}$ receives a message from channel $x$ and
continues with the continuation $K$. 
Whether a process send or receive message depends on the polarity of the connective.
Positive connectives, whose right rule is not invertible, will send a message in its right rule and receive a message in its left rule.
The intuition is that non-invertible rules always make a choice, while invertible rules does not contain any extra information. 

The proposition restricts the message type a channel can send or receive.
A channel of type $\textbf{1}$ or $\boldsymbol{\bot}$ can only send or receive a unit message, respectively.
In logic system, $\textbf{1}$ represents the empty truth, and $\boldsymbol{\bot}$ represents the empty falsehood.
Therefore, a unit message is also called an empty message since it does not contain any useful information.
An analogy can be drawn from unit message to computation suspension in functional programming. 
Under call-by-value setting, an expression $e$ needs to be eagerly evaluated before it can be involved in future computation.
However, if we replace $e$ by $\lambda (x : \texttt{unit}. e)$, then the computation of $e$ is suspended since a function is already a value.
We can retrieve the computation by applying the function to a unit value $()$. 
In the message passing setting, $\recv{x}{(() \Rightarrow P)}$ is a "suspended" process that waits for a unit message sent through channel $x$.

A channel of product type $\otimes$ and $\pare$ can send or receive a channel and its type evolved accordingly. 
For instance, in the \ruleref{tensorR} rule, the process $\send{x}{y}; P$ sends a channel $y$ along channel $x$ and continues with process $P$.
Before sending the channel $y$, the channel $x$ has type $A \otimes B$. After sending $y$ of type $A$, the channel $x$ evolved to type $B$.
The last message corresponds to choice type $\oplus$ and $\&$. A choice type is a collection of types distinguished by labels.
For instance, type \texttt{bool} can be written as $\oplus\{\text{true} : \textbf{1}, \text{false} : \textbf{1}\}$,
a choice type of two labels true and false with unit types. $\send{x}{l}$ sends a label $l$ along channel $x$.
This can be viewed as a process that makes a choice to select label $l$ from all the possible label collection $L$.
We add a subscript $k$ as a label to the \ruleref{orR} rule to indicate the process chooses $k$. The type of the channel evolved from
choice type to the corresponding type of label $k$.
$\recv{x}{(l \Rightarrow P_l)}$ provides a branching continuation that selects one branch to execute based on the label it receives.
We write $\forall l \in L$ to indicate that the process has prepared a process for each label in $L$.
In other words, if there is some label missing in the branching, the process will be stuck and cannot proceed.
However, we can exploit this feature by including non-exhaustive matches in our language, which will be discussed in the later section.

We know discuss the structural rules of our system. The weakening rule is represented by the channel cancellation process $\cancel{x}$.
Although we have two different weakening rules : $\ruleref{weakenL}$ and $\ruleref{weakenR}$, we do not distinct its difference in process.
The process $\cancel{x}$ discards the channel $x$ from the context and continues with process $P$ under the remaining context.
The $\ruleref{identity}$ rule is represented by the process $\fwd{y}{x}$, which passes the information from channel $y$ to channel $x$.
The cut rule spawns a child process $P$ with a newly created private channel $x$ and continues with parent process $Q$ under the remaining context.
The split of the exception handling context and the remaining rules about exceptions are discussed in the next section.

\section{Exception processes}
We first examine how exceptions are raised and handled in common functional programming languages. 
Below is a division function that returns the division of two numbers optionally. In other words,
if there is no division by zero, the function returns the division of two numbers.
Otherwise, it prints a message to console and returns none. 
\inputminted{ocaml}{code/div.ml} 
An important observation is sequential execution in computation.
Whether the print statement will be executed is not determined until the division is evaluated.
We adapt such idea in our exception handling mechanism. 
The execution of an exception handling process requires the execution of the main process,
and we use $\Omega$ to store the channels that communicate between the main process and the exception handling process.
 
A main process $P$'s $\Omega$ is a singleton context, which means it contains at most one channel.
If there are no channels in $\Omega$, this means process $P$ does not have any exception handling mechanism.
In other words, if $P$ raises an exception, this will be an uncaught exception. 
Nevertheless, if a process has more than one handling mechanism, we can always combine them into one.
\[
  \Omega = \cdot \mid x : \text{exn}
\]
The channel in $\Omega$ has type $\text{exn}$, which is defined as the following:
\[
  \text{exn} = \oplus\{\text{act} : \textbf{1}, \text{sil} : \textbf{1}\}
\]
As described before, a channel of type $\text{exn}$ sends and receives a label of act or sil. 
Act label represents activation of the exception handling process when an exception is raised.
Conversely, sil label represents the drop of the exception handling process when the process finished executing without any processes.

With enough introduction, we can look at the structure of $\ruleref{trycatch}$. 
It creates a channel $y$ and splits the resources to execute the main process $P$.
Meanwhile, a new channel $x$ of type \texttt{exn} is created and assigned to $P$.
The process \texttt{erecv} is a derived form which is defined by the following:
\begin{align*}
  \Gamma \vdash \text{erecv}\ x\ Q(y) :: \Delta ; \Omega \triangleq \Gamma \vdash \recv{x}{(\text{act} &\Rightarrow \recv{x}{(() \Rightarrow Q(y))} \\ 
  \mid \text{sil} &\Rightarrow \recv{x}{(() \Rightarrow \cancel{y}; \cancel{\Gamma}; \cancel{\Delta})})} :: \Delta; \Omega
\end{align*}
It waits a label send through channel $x$. 
If the label is \texttt{act}, which means an exception is raised by its main process, 
it starts to execute the process $Q(y)$ using the remaining context and the original exception handling context.
On the other side, if the main process executes finished without any exceptions, 
a \texttt{sil} label will lead to a branch of cancelling all resources prepared for the exception handling.
The exception handling context is inherited from the original process.

Now we go back to the body of the division function to see how exceptions are raised.
The division \texttt{a / b} is a partial function that will raise an exception when $b = 0$.
The exception is characterized by the exception constructor \texttt{Failure} with a message attached to it.
In the example above, we do not utilize the information stored in the exception. 
We follow the same structure in our system, instead of raising an exception with value, 
we raise a process as described in $\ruleref{raise}$. 
$\craise{P}$ raises an exception and continue to execute with process $P$. 
Right now, we require the exception to be caught by the exception handling process.
This invariant is enforced by requires $\Omega$ is non-empty.
The restriction can be relaxed, since uncaught exceptions are common in programming languages. 
We explore this feature in the later chapter.

\chapter{Runtime semantics}
\section{Configuration}
To formalize the runtime semantics, we can view each single process as an individual object.
The start of the program can be viewed as a configuration with a single object.
During the execution of the program, new processes will be spawned and adding new process object into the configuration.
We define the configuration $\config$ in \cref{fig:config}.
\begin{figure}[H]
  \centering
  \begin{tabular}{r r r l l}
    Configuration & $\config$ & $::=$ & $\cdot$ & empty configuration \\
    & & $\mid$ & $\config_1, \config_2$ & join configuration \\
    & & $\mid$ & $\procObj{\Gamma}{\Delta}{\Omega}{P}$ & process object
   \end{tabular}
  \caption{Syntax of configuration}
  \label{fig:config}
\end{figure}
Empty configuration is an empty multiset that does not contain any process object.
A single process object of form $\procObj{\Gamma}{\Delta}{\Omega}{P}$ represents a process $P$
communicates along the channels in $\Gamma$ and $\Delta$ and has an exception handling context $\Omega$.
During the transition of the program, the meta variables in the process object may change accordingly.
Lastly, the join combines two configuration into one configuration.

To avoid the situation of bad programs, where one channel receives a label message and has a unit continuation, 
we establish the typing judgement for configuration of form $\Phi \vdash \config :: \Phi'$. The configuration $\config$
uses channels in $\Phi$ and provides channels $\Phi'$. For instance, if a configuration $C$ uses channel $a : A$ and provides channel $b : B$,
then $\Phi, a : A \vdash \config :: b : B, \Phi$ holds. We provide the relevant rules in \cref{fig:configtyping}.
\begin{figure}[H]
  \centering
  \begin{rules}
    \defrule[empty][config-empty]{}{
      \Phi \vdash \cdot :: \Phi
    }
    \qquad
    \defrule[join][config-join]{
      \Phi \vdash \config_1 :: \Phi' \\ \Phi' \vdash \config_2 :: \Phi''
    }{
      \Phi \vdash \config_1, \config_2 :: \Phi''
    }\\
    \defrule[object][config-object]{}{
      \Phi, \Gamma \vdash \procObj{\Gamma}{\Delta}{\Omega}{P} :: \Delta, \Phi
    }
  \end{rules}
  \caption{Typing judgement of configuration}
  \label{fig:configtyping}
\end{figure}
$\ruleref{config-empty}$ states that an empty configuration does not use any channels and provides the same channels.
We add an arbitrary context $\Phi$ on both sides to generalize the $\ruleref{config-object}$ rule, since there may be channels that are not used by process $P$.
$\ruleref{config-join}$ combines two configurations $\config_1$ and $\config_2$ into one configuration $\config$ by some certain order.
This may contradict with the intuition that the configuration is an unordered set where $\config_1, \config_2$ should be as same as $\config_2, \config_1$.
Here, we require that there exists an ordering of the configuration such that it is well-typed.
Such ordering is not unique, apparently. Consider an example where $\config_1 = \procObj{\cdot}{a : A}{\Omega_1}{P}$ and $\config_2 = \procObj{b : B, c : C}{\cdot}{\Omega_2}{Q}$.
We can join these two configurations in two ways: $\config = \config_1, \config_2$ and $\config = \config_2, \config_1$ where $b : B, c : C \vdash \config :: a : A$.
Using the \ruleref{config-object}, we can find such $\Phi' = a : A, b : B, c : C$ for the first way and $\Phi' = \cdot$ for the second way.
However, if we change $\config_2$ into $\procObj{a : A, b : B}{\cdot}{\Omega_2}{Q}$, the overall configuration $b : B \vdash \config :: \cdot$ still type checks, 
but the ordering is unique.
It cannot be the case that $\config = \config_2, \config_1$, and the reason for that is because $\config_1$ provides channel $a$ that is used by $\config_2$.
By this observation, two configurations can be swapped if none of the channels provided by the first configuration are not used by the second configuration.

Besides the configuration, we also need a globally defined set to store the channels that are cancelled during the execution, call it $\cancelSet$.
The main reason why we need to keep track of this set is because the cancellation of a channel may affect the execution of other processes.
Every channel can be viewed as a segment that has two endpoints. In the original execution, one endpoint will send a message and the other endpoint is a continuation that waits for this message.
However, if one endpoint is cancelled, the other endpoint should also be cancelled accordingly. 
Otherwise, the process will be stuck and cannot proceed. We call this procedure as cancellation propagation.

To conclude, the state of the computation is a pair of current configuration and cancelled sets $\langle \config, \cancelSet \rangle$.
\section{Recursion}
Recursion is a very practical tool in programming. We do also want such feature in our system.
However, the formalization of recursion has little to do with logics. We achieve such equirecursive by having a signature $\Sigma_{\text{decl}}$ and a structure $\Sigma_{\text{defn}}$,
whose syntax is defined in \cref{fig:syntaxsig}.
\begin{figure}[H]
  \centering
  \begin{tabular}{r r l}
    $\Sigma_{\text{decl}}$ & $::=$ & $\cdot$ \\
    & $\mid$ & $t : A$ \\
    & $\mid$ & $p : (\Gamma, \Delta)$ \\
    & $\mid$ & $\Sigma_{\text{decl}1}, \Sigma_{\text{decl}2}$ \\  
    $\Sigma_{\text{defn}}$ & $::=$ & $\cdot$ \\
    & $\mid$ & $t = A$ \\
    & $\mid$ & $p (y_1, y_2, \ldots, y_m)[x_1, x_2, \ldots, x_n]= P$ \\
    & $\mid$ & $\Sigma_{\text{defn}1}, \Sigma_{\text{defn}2}$
    \end{tabular}
  \caption{Syntax of signature and structure}
  \label{fig:syntaxsig}
\end{figure}
A signature is a set of type declaration $t : A$ and process declaration $p : (\Gamma, \Delta)$.
Such signature can be determined when scanning through the whole program.
We want to ensure that all the definition in the program is well-defined based on the declarations.
This structure records both type and process definition. A type definition has the form $t = A$, where 
$t$ is a type identifier and $A$ is a proposition. Process definition has the form $p (y_1, y_2, \ldots, y_m) [x_1, x_2, \ldots, x_n] = P$.
The identification includes a process name $p$, a list of output channels $y_1, y_2, \ldots, y_m$ and a list of input channels $x_1, x_2, \ldots, x_n$.
The process such identification represents is $P$. We use the judgement $\Sigma_{\text{decl}} \vdash \Sigma_{\text{defn}} \textbf{ struct}$ to represent that
$\Sigma_{\text{defn}}$ is a valid structure given all the declarations in $\Sigma_{\text{decl}}$. We present the rules for signature in \cref{fig:sig}. 
The judgement for well-formed type $\Sigma_{\text{decl}} \vdash A \textbf{ type}$ and well-formed process $\Sigma_{\text{decl}} \vdash P \textbf{ proc}$ can be defined by looking at the signature, and thus we omit the rules here.
\begin{figure}[H]
  \centering
  \begin{rules}
    \defrule[empty][sig-empty]{}{
      \Sigma_{\text{decl}} \vdash \cdot \textbf{ struct}
    }
    \qquad
    \defrule[typedef][sig-join]{
      \Sigma_{\text{decl}} \vdash \Sigma_{\text{defn}} \textbf{ struct} \\ \Sigma_{\text{decl}} \vdash A \textbf{ type}
    }{
      \Sigma_{\text{decl}} \vdash \Sigma_{\text{defn}}, t = A \textbf{ struct}
    }\\
    \defrule[procdef][sig-object]{
      \Sigma_{\text{decl}} \vdash \Sigma_{\text{defn}} \textbf{ struct} \\ \Sigma_{\text{decl}} \vdash P(x_1,x_2,\ldots,x_n,y_1,y_2,\ldots,y_m) \textbf{ proc}
    }{
      \Sigma_{\text{decl}} \vdash \Sigma_{\text{defn}}, p (y_1, y_2, \ldots, y_m) [x_1, x_2, \ldots, x_n] = P \textbf{ struct}
    }
  \end{rules}
  \caption{Judgement of well-formed structure}
  \label{fig:sig}
\end{figure}
We present some examples of recursive types that will be used in future examples.
\begin{itemize}
  \item Natural number \texttt{nat}
  \[
    \texttt{nat} \triangleq \oplus\{\text{zero} : \textbf{1}, \text{succ} : \texttt{nat}\}
  \]
  The definition of natural number is a choice type of two labels \texttt{zero} and \texttt{succ},
  where \texttt{zero} represents the number $0$ and \texttt{succ} represents the successor of a natural number.
  This looks similar to the inductive type $\mu(t.1 + t)$.
  \item List of natural numbers \texttt{list}
  \[
    \texttt{list} \triangleq \oplus\{\text{nil} : \textbf{1}, \text{cons} : \texttt{nat} \otimes \texttt{list}\}
  \]
  List of nature numbers is also a choice type of two labels \texttt{nil} and \texttt{cons}.
  In the \texttt{cons} label, it contains multiplicative product of \texttt{nat} and \texttt{list}.
  To ensure \texttt{list} is well-defined, we need to have a type definition for \texttt{nat} in the signature. 
\end{itemize}
To utilize the recursion process, we add a new process \textbf{call} to activate another process in \cref{fig:extended}.
A process can call itself to achieve self recursion.
\begin{figure}[H]
  \centering
  \begin{tabular}{r r r l}
    Processes & $P, Q$ & $::=$ & $\ldots$ \\
    & & $\mid$ & $\call{p}{y_1, y_2, \ldots, y_m}{x_1, x_2, \ldots, x_n}$
  \end{tabular}
  \begin{rules}
    \defrule[call][call]{
      \Sigma_{\text{decl}} \vdash p (y_1, y_2, \ldots, y_m) [x_1, x_2, \ldots, x_n] = P \textbf{ struct} \\
      \judge{\Gamma}{P}{\Delta}{\Omega}
    }{
      \judge{\Gamma}{\call{p}{y_1, y_2, \ldots, y_m}{x_1, x_2, \ldots, x_n}}{\Delta}{\Omega}
    }\\
    \text{where } \Gamma = x_1 : A_1, x_2 : A_2, \ldots, x_n : A_n \text{ and } \Delta = y_1 : C_1, y_2 : C_2, \ldots, y_m : C_m
  \end{rules}
  \caption{Extended syntax and static semantics of the type system}
  \label{fig:extended}
\end{figure}
The \textbf{call} process looks up the signature $\Sigma$ and finds the process defined by identifier $p$.
There should be no future processes after the \textbf{call}, thus we require process $P$ takes all the channels in $\Gamma$ and $\Delta$.
The exception handling context $\Omega$ is inherited from the original process. 
\section{Reduction}
In the future discussion, we distinct channels that are allocated by using $a,b,c,\ldots$ for newly created channels.
We use $x,y,z,\ldots$ for channels variables that requires substitution by another allocated channel.
For instance, $\spawn{P}{Q}{a}$ should not be allowed since channel $a$ should be a variable instead of an allocated channel.
Similarly, $\cancel{x}$ is neither invalid since we cannot cancel a channel that is not allocated.

The reduction of the configuration is based on linear inference. 
New process objects are created when a new process is spawned. 
Correspondingly, process objects may be destroyed when the process is finished or evolves to another process.
A reduction step is represented by $\langle \config; \cancelSet \rangle \longrightarrow \langle \config'; \cancelSet' \rangle$.
The reduction rules only examine parts of the configuration. The untouched parts are preserved in the new configuration.
We first present the standard reduction rule without exceptions in \cref{fig:stdreduction}.

Most of the standard rules represent message reduction. For instance,
in \stepref{label-reduction-r}{label-r}, one process sends a label $k$ through channel $a$ 
and in another process it waits a label from $a$ and pass it to a branching continuation.
Such two processes can make progress simultaneously. As the first process continue to execute the remaining process $P$,
the second process chooses process $P_k$ to execute. 
By the duality of the propositions, each reduction has two versions of rules, one for the right rule and one for the left rule.

In the \stepref{forward}{linking} rule, the process $\fwd{c}{a}$ passes the information from channel $a$ to channel $c$.
We achieve such effect by replacing all the usage of channel $a$ by channel $c$ in the continuation process.
Since the invariant that every channel has two endpoints holds, we know there is only one such process where we need to do the substitution.
The \stepref{spawn}{spawn} rule splits the original object into two process objects.
The first object contains the new process $P$ and the second object contains the original process $Q$.
A new channel $a$ is created and put into the relevant context. We require that the channel $a$ is fresh globally to avoid naming conflicts.
Moreover, the contexts are split based on the meta variables in each process. 
According to the static rules, there must be a valid splitting of the context that maintains the typing of the configuration.
In the \stepref{call}{call} rule, we assume the signature is well-formed, thus there exists a process declaration for $p$.
We find such definition $p (y_1, y_2, \ldots, y_m) [x_1, x_2, \ldots, x_n] = P$ and execute the process $P$.
We can drop a process object when the process is finished. 
A process is finished if all the channels in the contexts are used and there is no remaining processes,
which is formalized by the \stepref{finish}{end} rule.
\begin{figure}[H]
  \begin{alignat}{4}
    \label{unit-reduction-r} \textsc{[unit-r]} & ~ 
    \Braket{
      \begin{array}{l}
        \procObj{\cdot}{a : \textbf{1}}{\Omega_1}{\send{a}{()}} \\
        \procObj{\Gamma, a : \textbf{1}}{\Delta}{\Omega_2}{\recv{a}{(() \Rightarrow P)}}
      \end{array}
      ; \cancelSet
    } & ~ \longrightarrow & ~ 
    \Braket{
      \begin{array}{l}
        \procObj{\cdot}{\cdot}{\Omega_1}{\cdot} \\
        \procObj{\Gamma}{\Delta}{\Omega_2}{P}
      \end{array}
      ; \cancelSet
    } \tag*{} \\
    \label{unit-reduction-l} \textsc{[unit-l]} & ~ 
    \Braket{
      \begin{array}{l}
        \procObj{a : \boldsymbol{\bot}}{\cdot}{\Omega_1}{\send{a}{()}} \\
        \procObj{\Gamma}{a : \boldsymbol{\bot}, \Delta}{\Omega_2}{\recv{a}{(() \Rightarrow P)}}
      \end{array}
      ; \cancelSet
    } & ~ \longrightarrow & ~ 
    \Braket{
      \begin{array}{l}
        \procObj{\cdot}{\cdot}{\Omega_1}{\cdot} \\
        \procObj{\Gamma}{\Delta}{\Omega_2}{P}
      \end{array}
      ; \cancelSet
    } \tag*{} \\
    \label{channel-reduction-r} \textsc{[channel-r]} & ~ 
    \Braket{
      \begin{array}{l}
        \procObj{\Gamma_1, a : A}{c : A\otimes B, \Delta_1}{\Omega_1}{\send{c}{a}; P} \\
        \procObj{\Gamma_2, c : A \otimes B}{\Delta_2}{\Omega_2}{\recv{c}{(x \Rightarrow P(x))}}
      \end{array}
      ; \cancelSet
    } & ~ \longrightarrow & ~ 
    \Braket{
      \begin{array}{l}
        \procObj{\Gamma_1}{c : B, \Delta_1}{\Omega_1}{P} \\
        \procObj{\Gamma_2, c : B}{\Delta_2}{\Omega_2}{P(a)}
      \end{array}
      ; \cancelSet 
    } \tag*{} \\
    \label{channel-reduction-l} \textsc{[channel-l]} & ~ 
      \Braket{
        \begin{array}{l}
          \procObj{\Gamma_1, c : A \pare B}{a : A, \Delta_1}{\Omega_1}{\send{c}{a}; P} \\
          \procObj{\Gamma_2}{c : A \pare B, \Delta_2}{\Omega_2}{\recv{c}{(x \Rightarrow P(x))}}
        \end{array}
        ; \cancelSet
      } & ~ \longrightarrow & ~ 
      \Braket{
        \begin{array}{l}
          \procObj{\Gamma_1}{c : B, \Delta_1}{\Omega_1}{P} \\
          \procObj{\Gamma_2, c : B}{\Delta_2}{\Omega_2}{P(a)}
        \end{array}
        ; S\cancelSet
    } \tag*{} \\
    \label{label-reduction-r} \textsc{[label-r]} & ~ 
      \Braket{
        \begin{array}{l}
          \procObj{\Gamma_1}{a : \oplus\{l : A_l\}_{l \in L}, \Delta_1}{\Omega_1}{\send{a}{k}; P} \\
          \procObj{\Gamma_2, a : \oplus\{l : A_l\}_{l \in L}}{\Delta_2}{\Omega_2}{\recv{a}{(l \Rightarrow P_l)_{l \in L}}}
        \end{array}
        ; \cancelSet
      } & ~ \longrightarrow & ~ 
      \Braket{
        \begin{array}{l}
          \procObj{\Gamma_1}{a : A_k, \Delta_1}{\Omega_1}{P} \\
          \procObj{\Gamma_2, a : A_k}{\Delta_2}{\Omega_2}{P_k}
        \end{array}
        ; \cancelSet
    } \tag*{} \\
    \label{label-reduction-l} \textsc{[label-l]} & ~ 
      \Braket{
        \begin{array}{l}
          \procObj{\Gamma_1, a : \&\{l : A_l\}_{l \in L}}{\Delta_1}{\Omega_1}{\send{a}{k}; P} \\
          \procObj{\Gamma_2}{a : \&\{l : A_l\}_{l \in L}, \Delta_2}{\Omega_2}{\recv{a}{(l \Rightarrow P_l)_{l \in L}}}
        \end{array}
        ; \cancelSet
      } & ~ \longrightarrow & ~ 
      \Braket{
        \begin{array}{l}
          \procObj{\Gamma_1, a : A_k}{\Delta_1}{\Omega_1}{P} \\
          \procObj{\Gamma_2}{a : A_k, \Delta_2}{\Omega_2}{P_k}
        \end{array}
        ; \cancelSet
    } \tag*{} \\
    \label{forward} \textsc{[linking]} & ~ 
      \Braket{
        \begin{array}{l}
          \procObj{a : A}{c : A}{\Omega_1}{\fwd{c}{a}} \\
          \procObj{\Gamma}{a : A, \Delta}{\Omega_2}{P(a)}
        \end{array}
        ; \cancelSet
      } & ~ \longrightarrow & ~ 
      \Braket{
        \begin{array}{l}
          \procObj{\cdot}{\cdot}{\Omega_1}{\cdot} \\
          \procObj{\Gamma}{c : A, \Delta}{\Omega_2}{P(c)}
        \end{array}
        ; \cancelSet
    } \tag*{} \\
    \label{spawn} \textsc{[spawn]} & ~ 
      \Braket{
        \begin{array}{l}
          \procObj{\Gamma_1, \Gamma_2}{\Delta_1, \Delta_2}{\Omega}{\spawn{P}{Q}{x}}
        \end{array}
        ; \cancelSet
      } & ~ \longrightarrow & ~ 
      \Braket{
        \begin{array}{l}
          \procObj{\Gamma_1}{a : A, \Delta_1}{\cdot}{P(a)} \\
          \procObj{\Gamma_2, a : A}{\Delta_2}{\Omega}{Q(a)}
        \end{array}
        ; \cancelSet
    } \tag*{} \\
    \label{call} \textsc{[call]} & ~ 
      \Braket{
        \begin{array}{l}
          \procObj{\Gamma}{\Delta}{\Omega}{\call{p}{y_1, y_2, \ldots, y_m}{x_1, x_2, \ldots, x_n}}
        \end{array}
        ; \cancelSet
      } & ~ \longrightarrow & ~ 
      \Braket{
        \begin{array}{l}
          \procObj{\Gamma}{\Delta}{\Omega}{P}
        \end{array}
        ; \cancelSet
    } \tag*{} \\
    \label{finish} \textsc{[end]} & ~ 
      \Braket{
        \begin{array}{l}
          \procObj{\cdot}{\cdot}{\cdot}{\cdot}
        \end{array}
        ; \cancelSet
      } & ~ \longrightarrow & ~ 
      \Braket{
        \begin{array}{l}
          \cdot
        \end{array}
        ; \cancelSet
    } \tag*{}
  \end{alignat}
  \raggedleft
  \caption{Standard reductions of configuration}
  \label{fig:stdreduction}
\end{figure}
Now we examine the reduction rules in channel cancellation as listed in \cref{fig:cancelreduction}.
The cancellation process drops a channel from the context and adds it to the cancellation set.
We have two different rules for the right and left cancellation for the channel $a$ in the context $\Gamma$ and $\Delta$, respectively.
The channel propagation rule states that if a channel $a$ is cancelled, then the process that involves the communication of $a$ should also be cancelled.
Cancelling a process is achieved by replacing the process with a process that cancels all the channels in the context. 
\begin{figure}[H]
  \begin{alignat}{4}
    \label{cancelR} \textsc{[cancel-r]} & ~ 
    \Braket{
      \begin{array}{l}
        \procObj{\Gamma}{a : A, \Delta}{\Omega}{\cancel{a}; P}
      \end{array}
      ; \cancelSet
    } & ~ \longrightarrow & ~ 
    \Braket{
      \begin{array}{l}
        \procObj{\Gamma}{\Delta}{\Omega}{P}
      \end{array}
      ; \cancelSet \cup \{a\}
    } \tag*{} \\
    \label{cancelL} \textsc{[cancel-l]} & ~ 
    \Braket{
      \begin{array}{l}
        \procObj{\Gamma, a : A}{\Delta}{\Omega}{\cancel{a}; P}
      \end{array}
      ; \cancelSet
    } & ~ \longrightarrow & ~ 
    \Braket{
      \begin{array}{l}
        \procObj{\Gamma}{\Delta}{\Omega}{P}
      \end{array}
      ; \cancelSet \cup \{a\}
    } \tag*{} \\
    \label{cancel-prop-r} \textsc{[cancel-prop-r]} & ~ 
    \Braket{
      \begin{array}{l}
        \procObj{\Gamma}{a : A, \Delta}{\Omega}{P(a)}
      \end{array}
      ; \cancelSet \cup \{a\}
    } & ~ \longrightarrow & ~ 
    \Braket{
      \begin{array}{l}
        \procObj{\Gamma}{\Delta}{\Omega}{\cancel{\Gamma}; \cancel{\Delta}}
      \end{array}
      ; \cancelSet \cup \{a\}
    } \tag*{} \\
    \label{cancel-prop-l} \textsc{[cancel-prop-l]} & ~ 
    \Braket{
      \begin{array}{l}
        \procObj{\Gamma, a : A}{\Delta}{\Omega}{P(a)}
      \end{array}
      ; \cancelSet \cup \{a\}
    } & ~ \longrightarrow & ~ 
    \Braket{
      \begin{array}{l}
        \procObj{\Gamma}{\Delta}{\Omega}{\cancel{\Gamma}; \cancel{\Delta}}
      \end{array}
      ; \cancelSet \cup \{a\}
    } \tag*{}
  \end{alignat}
  \raggedleft
  \caption{Cancellation reductions of configuration}
  \label{fig:cancelreduction}
\end{figure}
Lastly we look at the exception reductions in \cref{fig:exnreduction}. The \stepref{try-catch}{try-catch} rule 
spawns two processes, very similar to \stepref{spawn}{spawn}.
Besides, it creates another channel $a$ of type \texttt{exn} and works as the exception handling context for $P$.
The exception handling process $Q$ uses the channel $a$ to wait for exception activation and 
the channel $c$ to communicate with the process $P$. When a process raises an exception, 
we activate the exception handling by creating a new process object that sends a label \texttt{act} through channel $a$.
Similarly, when a process finishes without any exceptions and there is an exception handling channel, then
we send a label \texttt{sil} through channel $a$ to drop the exception handling process.
\begin{figure}[H]
  \begin{alignat}{4}
    \label{try-catch} \textsc{[try-catch]} & ~ 
    \Braket{
      \begin{array}{l}
        \procObj{\Gamma}{\Delta}{\Omega}{\trycatch{P}{Q}{y}}
      \end{array}
      ; \cancelSet
    } & ~ \longrightarrow & ~ 
    \Braket{
      \begin{array}{l}
        \procObj{\Gamma_1}{\Delta_1, c : A}{a : \text{exn}}{P(c)} \\
        \procObj{\Gamma_2, a : \text{exn}, c : A}{\Delta_2}{\Omega}{\text{erecv}\ a\ Q(c)}
      \end{array}
      ; \cancelSet
    } \tag*{} \\
    \label{activation} \textsc{[activate]} & ~ 
    \Braket{
      \begin{array}{l}
        \procObj{\Gamma}{\Delta}{a : \text{exn}}{\craise{P}}
      \end{array}
      ; \cancelSet
    } & ~ \longrightarrow & ~ 
    \Braket{
      \begin{array}{l}
        \procObj{\Gamma}{\Delta}{\cdot}{P} \\
        \procObj{\cdot}{a : \text{exn}}{\cdot}{\send{a}{\text{act}}; \send{a}{()}}
      \end{array}
      ; \cancelSet
    } \tag*{} \\
    \label{silence} \textsc{[silent]} & ~ 
    \Braket{
      \begin{array}{l}
        \procObj{\cdot}{\cdot}{a : \text{exn}}{\cdot}
      \end{array}
      ; \cancelSet
    } & ~ \longrightarrow & ~ 
    \Braket{
      \begin{array}{l}
        \procObj{\cdot}{a : \text{exn}}{\cdot}{\send{a}{\text{sil}}; \send{a}{()}}
      \end{array}
      ; \cancelSet
    } \tag*{}
  \end{alignat}
  \raggedleft
  \caption{Exception reductions of configuration}
  \label{fig:exnreduction}
\end{figure}
\section{Safety theorems}
To ensure the safety of the system, we first need to show the typing of the configuration is preserved as the computation proceeds.
Such property is stated in \cref{thm:preservation}.
\begin{theorem}[Session Fidelity]\label{thm:preservation}
  Given a state $\langle \config, \cancelSet \rangle$, if $\Phi \vdash \config :: \Phi'$ for some $\Phi, \Phi'$
  and $\langle \config, \cancelSet \rangle \longrightarrow \langle \config', \cancelSet' \rangle$,
  then $\Phi \vdash \config' :: \Phi'$.
\end{theorem}
The proof of the theorem is casing over the forms of reduction. 
We will show a few interesting cases to demonstrate how proof proceeds.
\begin{proof}
  We induct on the forms of reduction.
  \begin{itemize}
    \item [\stepref{spawn}{spawn}] In this case, $\config = (\config_L, \procObj{\Gamma}{\Delta}{\Omega}{\spawn{P}{Q}{x}}, \config_R)$ for some $\config_L$ and $\config_R$. 
    Moreover, we assume the following typing judgements hold.
    \begin{align*}
      \Phi & \vdash \config_L :: \Phi_L \\
      \Phi_L & \vdash \procObj{\Gamma}{\Delta}{\Omega}{\spawn{P}{Q}{x}} :: \Phi_R\\
      \Phi_R & \vdash \config_R :: \Phi'
    \end{align*}
    We can split the context $\Gamma$ and $\Delta$ into $\Gamma_1, \Gamma_2$ and $\Delta_1, \Delta_2$ based on the meta variables in $P$ and $Q$.
    By the reduction rule, we know
    \begin{align*}
      \config' &= \config_L, \procObj{\Gamma_1}{a : A, \Delta}{\cdot}{P(a)}, \procObj{\Gamma_2, a : A}{\Delta_2}{\Omega}{Q(a)}, \config_R \\
      \cancelSet' &= \cancelSet
    \end{align*}
    where $a$ is a globally fresh channel.
    To build the typing judgement for the new state, we apply inversion to the typing 
    \[
      \Phi_L \vdash \procObj{\Gamma}{\Delta}{\Omega}{\spawn{P}{Q}{x}} :: \Phi_R
    \]
    We find that for some $\Phi_L'$ and $A$, using the new channel $a$, we must have
    \begin{align*}
      \Phi_L &= (\Phi_L', \Gamma_1, \Gamma_2) \\
      \Gamma_1 & \vdash P(a) :: \Delta_1, a : A; \cdot \\
      \Gamma_2, a : A & \vdash Q(a) :: \Delta_2; \Omega \\
      \Phi_R &= (\Phi_L', \Delta_1, \Delta_2)
    \end{align*}
    Now we can construct a typing derivation for $\config'$
    \begin{align*}
      \Phi & \vdash \config_L :: \Phi_L \\
      \Phi_L &= (\Phi_L', \Gamma_1, \Gamma_2) \\
      \Phi_L', \Gamma_1, \Gamma_2 & \vdash \procObj{\Gamma_1}{a : A, \Delta}{\cdot}{P(a)} :: (\Phi_L', \Gamma_2, \Delta_1, a : A) \\
      \Phi_L', \Gamma_2, \Delta_1, a : A & \vdash \procObj{\Gamma_2, a : A}{\Delta_2}{\Omega}{Q(a)} :: (\Phi_L', \Delta_1, \Delta_2) \\
      \Phi_R &= (\Phi_L', \Delta_1, \Delta_2) \\
      \Phi_L & \vdash \config_R :: \Phi'
    \end{align*}
    This concludes this case of type preservation.
  \item [\stepref{cancelL}{cancel-l}] In this case, $\config = (\config_L, \procObj{\Gamma, a : A}{\Delta}{\Omega}{\cancel{a}; P}, \config_R)$.
    We assume the following typing judgements hold.
    \begin{align*}
      \Phi & \vdash \config_L :: \Phi_L \\
      \Phi_L & \vdash \procObj{\Gamma, a : A}{\Delta}{\Omega}{\cancel{a}; P} :: \Phi_R \\
      \Phi_R & \vdash \config_R :: \Phi'
    \end{align*}
    By the reduction rule, we know
    \begin{align*}
      \config' &= \config_L, \procObj{\Gamma}{\Delta}{\Omega}{P}, \config_R \\
      \cancelSet' &= \cancelSet \cup \{a\}
    \end{align*}
    We can apply inversion to the typing judgement
    \[
      \Phi_L \vdash \procObj{\Gamma, a : A}{\Delta}{\Omega}{\cancel{a}; P} :: \Phi_R
    \]
    to find that for some $\Phi_L'$, we must have
    \begin{align*}
      \Phi_L & = (\Phi_L', \Gamma) \\
      \Gamma & \vdash P :: \Delta; \Omega \\
      \Phi_R & = (\Phi_L', \Delta)
    \end{align*}
    Now we can construct a typing derivation for $\config'$
    \begin{align*}
      \Phi & \vdash \config_L :: \Phi_L \\
      \Phi_L & = (\Phi_L', \Gamma) \\
      \Phi_L', \Gamma & \vdash \procObj{\Gamma}{\Delta}{\Omega}{P} :: (\Phi_L', \Delta) \\
      \Phi_R & = (\Phi_L', \Delta) \\
      \Phi_R & \vdash \config_R :: \Phi'
    \end{align*}
    This concludes this case of type preservation.
  \end{itemize}
\item [\stepref{silence}{silent}] In this case, $\config = (\config_L, \procObj{\cdot}{\cdot}{a : \text{exn}}{\cdot}, \config_R)$.
  We assume the following typing judgements hold.
  \begin{align*}
    \Phi & \vdash \config_L :: \Phi_L \\
    \Phi_L & \vdash \procObj{\cdot}{\cdot}{a : \text{exn}}{\cdot} :: \Phi_R \\
    \Phi_R & \vdash \config_R :: \Phi'
  \end{align*}
  Applying the inversion, we must have $\Phi_R = \Phi_L$. By the reduction rule, we know
  \begin{align*}
    \config' &= \config_L, \procObj{\cdot}{a : \text{exn}}{\cdot}{\send{a}{\text{sil}}; \send{a}{()}}, \config_R \\
    \cancelSet' &= \cancelSet
  \end{align*}
  Since channel $a$ has type \texttt{exn}, we can safely omit the explicit usage of $a : \text{exn}$ and 
  construct a typing derivation for $\config'$ as
  \begin{align*}
    \Phi & \vdash \config_L :: \Phi_L \\
    \Phi_L & \vdash \procObj{\cdot}{a : \text{exn}}{\cdot}{\send{a}{\text{sil}}; \send{a}{()}} :: \Phi_L \\
    \Phi_R & = \Phi_L \\
    \Phi_R & \vdash \config_R :: \Phi'
  \end{align*}
  This concludes this case of type preservation.
\end{proof}
Showing every reduction terminates is not possible in our system because of recursion. 
For instance, a process \texttt{foo} can call itself such that the execution will never terminate.
However, we are able to show that well-typed configurations will not get stuck.
In other words, a configuration is either final, which means all process objects attempt to communicate along an external channel,
or it can reduce to another configuration. We formalize this property in \cref{thm:progress}.
\begin{theorem}[Deadlock Freedom]\label{thm:progress}
  Given a state $\langle \config; \cancelSet \rangle$ such that $\cdot \vdash \config :: \Phi$, then either $\config$ is final, or 
  $\langle \config; \cancelSet \rangle \longrightarrow \langle \config'; \cancelSet' \rangle$ for some $\config', \cancelSet'$.
\end{theorem}
We require the configuration does not take any input channels. 
Otherwise, the configuration may get stuck because the messages from the input channel may not be available.
The collection of external channels is represented by $\Phi$. Such channels have only one endpoint.
In other words, if $\config$ satisfies $\cdot \vdash \config :: \Phi$, then $\config$ is a closed configuration because it does not depend on any channels.
\begin{proof}
  We prove this theorem by induction on the structure of the configuration, right to left.
  Since the typing of the configuration requires some ordering, a right to left induction provides useful induction hypothesis.
  If $\config = \cdot$, then $\config$ is trivially final and the theorem holds.
  Now we assume the followings: 
  \begin{align*}
    \config &= (\config_L, \procObj{\Gamma}{\Delta}{\Omega}{P}) \\
    \cdot & \vdash \config_L :: (\Phi', \Gamma) \\
    \Phi', \Gamma & \vdash \procObj{\Gamma}{\Delta}{\Omega}{P} :: (\Phi', \Delta) \\
    \Phi & = (\Phi, \Delta) \\
    \cdot & \vdash \config :: \Phi
  \end{align*}
  for a process object $\procObj{\Gamma}{\Delta}{\Omega}{P}$ and $\Phi, \Phi'$.
  
  Now we distinguish the cases by the structure of process $P$.
  \begin{itemize}
    \item [\ruleref{cut}] In this case $P = \spawn{P_1}{P_2}{x}$. By induction hypothesis,
    we know that $\config_L$ is either final or can reduce to another configuration $\config_L'$ with some cancelled set $\cancelSet'$.
    If it reduces to $\langle \config_L'; \cancelSet' \rangle$, then $\langle \config; \cancelSet \rangle \longrightarrow 
    \langle (\config_L', \procObj{\Gamma}{\Delta}{\Omega}{P}); \cancelSet' \rangle$.
    Otherwise, by reduction, we know $\langle \config; \cancelSet \rangle \longrightarrow
    \langle (\config_L, \procObj{\Gamma_1}{a : A, \Delta_1}{\cdot}{P_1(a)}, \procObj{\Gamma_2, a : A}{\Delta_2}{\Omega}{P_2(a)}); \cancelSet \rangle$
    with a proper split of the context.
    \item [\ruleref{weakenL}] In this case $P = \cancel{a}; P'$ and $\Gamma = \Gamma', a : A$. 
    For simplicity, we assume $\config_L$ is final.
    By reduction, we know $\langle \config; \cancelSet \rangle \longrightarrow \langle (\config_L, \procObj{\Gamma'}{\Delta}{\Omega}{P'}); \cancelSet \cup \{a\} \rangle$.
    \item [\ruleref{nothing}-exn] In this case $P = \cdot$ while $\Omega = a :$ \texttt{exn}.
    For simplicity, we assume $\config_L$ is final.
    By reduction, we know $\langle \config; \cancelSet \rangle \longrightarrow \langle (\config_L, \procObj{\cdot}{a : \text{exn}}{\cdot}{\send{a}{\text{sil}}; \send{a}{()}}); \cancelSet \rangle$.
  \end{itemize}
\end{proof}
\chapter{Interpreter}
To experiment with the proposed type system, we implement a simple interpreter in Ocaml. 
We name the source language EPass, an abbreviation for exceptional message passing. We don't have a target language.
Instead, we simulate the execution in Ocaml and make observation that outputs to the console screen.
There are four main phases in the interpreter: parsing, elaboration, type checking, and runtime simulation.
A complete implementation of the interpreter can be found \href{https://github.com/cekington/ePass}{here}.
\section{Grammar} 
We present the grammar of the EPass language in \cref{sec:grammar}. There are a few remarks about the grammar.
\begin{itemize}
  \item We use \texttt{type t = } $\ldots$ for type definition and \texttt{proc p} $(\ldots)\ [\ldots]$ \texttt{=} $\ldots$ for process definition.
  \texttt{exec} $p$ executes a closed process, a process without any input channels, and prints out the observation of the external channels. 
  \item We keep $\multimap$ as the linear implication in our language. Although we do not include it in our system, we have shown $A \multimap B$ is equivalent.
  Thus, $A \multimap B$ is viewed as a syntax sugar that will be elaborated to $A^\bot \pare B$ during elaboration.
  \item There is not a suitable Unicode character to represent $\pare$. We use @ to represent the multiplicative disjunction.
  \item We modify the try-catch process such that creating a new channel is not necessary. 
  This can be used when the main process and the exception handling process are independent with each other.
  Therefore, $\trycatch{P}{Q}{y}$ and $\textbf{try}\ P \textbf{ catch } Q$ are both valid try-catch processes.
  \item We distinguish identity and label by putting a ' character in front of the label. So the type \texttt{nat} in EPass looks like
  \[
    \texttt{nat} \triangleq \oplus\{\text{'zero} : 1 , \text{'succ} : \texttt{nat}\}
  \]
\end{itemize}
As checked by Menhir, a LR$(1)$ parser generator for OCaml, there are no ambiguity in the grammar.
So every source code that follows the grammar can be parsed into the external language properly.
The syntax of the external language can be found in \cref{sec:el}.
\section{Elaboration}
During the elaboration, we transform the external language into internal language, whose syntax is in \cref{sec:il}. There are two major goals in this phase.
\begin{itemize}
  \item We first remove the recursive definitions for types in the external language, which means types have at most one layer.
  This helps to simplify comparing the equality of two types. When we compare two types, we need to compare the outermost layer,
  and, if necessary, we can always expand the type by the newly created identity.

  For example, type definitions of \texttt{nat} and \texttt{list} in the external language 
  \lstinputlisting{code/elab-before.eps}
  will be elaborated to the internal language as
  \lstinputlisting{code/elab-after.eps}
  Besides type elaboration, we also remove the usage of linear application.
  \item After the elaboration, we check the every definition is well-formed by checking $\Sigma_\text{decl} \vdash \Sigma_\text{defn}$.
  We extract the declaration by scanning the whole program and build the definition during the elaboration.
  Type checking errors are reported for any ill-defined processes or types. 
  Additionally, some syntax allowed progresses that confuse the runtime semantics are also rejected.
  For instance, executing open processes and having duplicate labels in either type definition or branching continuation are ruled out.
\end{itemize}
\chapter{Other features}
\section{Uncaught exception}
\appendix
\chapter{EPass interpreter syntax} 
\section{Grammar} \label{sec:grammar}
\inputminted{text}{code/grammar.txt}
\section{External language} \label{sec:el}
\inputminted{ocaml}{code/el.ml}
\section{Internal language} \label{sec:il}
\inputminted{ocaml}{code/il.ml}
\backmatter

\printbibliography

\end{document}
