\documentclass[12pt, openany]{memoir}

\usepackage{latexsym,amsmath,amsfonts,amssymb,amsthm}
\usepackage{url}
\usepackage{proof}
\usepackage[style=alphabetic,natbib=true,backend=biber,maxbibnames=99]{biblatex}
\usepackage[colorlinks=true]{hyperref}
\usepackage[nameinlink,capitalize,noabbrev]{cleveref}
\usepackage{graphicx}
\RequirePackage[T1]{fontenc}
\RequirePackage[tt=false,type1=true]{libertine}
\RequirePackage[varqu]{zi4}
\RequirePackage[libertine]{newtxmath}
\usepackage{microtype}
\usepackage{cmutr}
\usepackage{epass}
\usepackage{minted}
\usepackage{graphicx}
\usepackage{tikz}
\usepackage{wasysym}
\usepackage{mathpartir}
\usepackage{stmaryrd} 
\usepackage{braket}
\usepackage{subcaption}
\usepackage{hyperref}

\hypersetup{colorlinks,linkcolor={red},citecolor={black},urlcolor={red}}  

\setlrmarginsandblock{1.25in}{*}{1}
\setulmarginsandblock{1.5in}{*}{1}
\setheaderspaces{*}{2\onelineskip}{*}
\checkandfixthelayout

\newcommand*{\pare}[0]{\mathbin{\bindnasrepma}}
\newcommand*{\send}[2]{\textbf{send}\ #1\ #2}
\newcommand*{\recv}[2]{\textbf{recv}\ #1\ #2}
\newcommand*{\call}[3]{\textbf{call}\ #1\ (#2)\ [#3]}
\newcommand*{\fwd}[2]{\textbf{fwd}\ #1\ #2}
\newcommand*{\cancel}[1]{#1 \lightning}
\newcommand*{\craise}[1]{\textbf{raise}\ #1}
\newcommand*{\trycatch}[3]{#3 \twoheadleftarrow	\textbf{try}\ #1(#3)\ \textbf{catch}\ #2(#3)}
\newcommand*{\spawn}[3]{#3 \leftarrow #1(#3);\ #2(#3)}
\newcommand*{\judge}[4]{#1 \vdash #2 :: #3; #4}
\newcommand*{\procObj}[4]{\textbf{proc}(#1/#2/#3/#4)}
\newcommand*{\config}[0]{\mathcal{C}}
\newcommand*{\cancelSet}[0]{\mathcal{S}}

\lstset{style=verb, language=epass, numbers=none}

% Check out the memoir manual for other chapter styles.
\chapterstyle{default}

\setsecnumdepth{subsection}

\nouppercaseheads
\makepagestyle{nonumbers}
\createmark{chapter}{left}{nonumber}{}{}
\createmark{section}{right}{nonumber}{}{}
\makeevenhead{nonumbers}{\thepage\qquad{\itshape\leftmark}}{}{}
\makeoddhead{nonumbers}{}{}{{\itshape\rightmark}\qquad\thepage}

\addbibresource{bibliography.bib}

\input{infrastructure.tex}

\begin{document}

\frontmatter

\pagestyle{empty}

\title{\textbf{Exceptions in a Message Passing Interpretation of Substructural Logic}}
\author{Shengchao Yang}

\keywords{Exceptions, Affine Logic, Session Types, Concurrent communication}

\maketitle

\pagestyle{nonumbers}

\begin{abstract}
  Session types are used to describe the structure of communications across channels. Previous research has established a message-passing interpretation of intuitionistic linear logic. 
  Meanwhile, communication failures have been an important research topic in session types. 
  However, the exception handling mechanism has not been well studied in the context of message passing. 
  To bridge this gap, we study the interpretation of classical affine logic and propose a new type system containing features such as explicit channel cancellation and exception handling constructors. 
  Our type system ensures program safety by enforcing session fidelity and deadlock freedom. 
  To experiment, we implemented an interpreter for our language and tested it on several examples to match the expected process behavior. 
  Additionally, we explore the possibility of representing some programming features, such as non-exhaustive matches, in our language using the exception mechanism.
\end{abstract}

\chapter{Acknowledgements}

TBD

\cleardoublepage
\tableofcontents

\mainmatter

\chapter{Introduction}

Linear logic \cite{Girard1987} is a refinement of intuitionistic logic that does not satisfy weakening and contraction. 
Weakening drops resources in the contest and contraction duplicates resources. 
It emphasizes the management of resources, where each formula should be used exactly once. 
Informally speaking, the assumption cannot be too strong for the conclusion, such as $A, B \vdash B$.

The Curry-Howard isomorphism states a correspondence between logical proof theory and computational type theory \cite{Howard1980}.
A computational interpretation of linear logic, first given by Abramsky, lays the foundation for the connection between $\pi$-calculus and linear logic \cite{Abramsky1933}. 
Later on, an expressive formulation of intuitionistic linear logic provides a correspondence between linear proofs and processes, 
which gives rise to two important ideas: proofs as processes \cite{Abramsky1994} and cut as computation \cite{Caires2014}.

On the other hand, exceptions have been a practical topic during the development of programming languages.
Programmers can utilize exceptions to write explicit control flow for their code. In most functional programming languages, exceptions are managed by expression constructors. 
For instance, in Standard ML, exceptions are raised by the keyword \texttt{raise} and caught by the keyword \texttt{handle} \cite{Milner1997}. 
In concurrent models, communication failures remain both inevitable and critical. 
Previous research applies affine session types that relax the linearity of session types to incorporate error handling \cite{Mos2014}.

Given the relationship between linear propositions and session types, our goal is to implement exceptions under the computational interpretation of linear logic.
However, exceptions are inherently incompatible with linear logic. 
Let us assume we have some kind of exception handler where part of its processes are designated to deal with exceptional situations. 
In other words, it will be activated if an exception is raised. 
This violates linearity, as the resources allocated for the exception handler will not be utilized if no exceptions occur. 
Affinity, on the other hand, allows us to model such behavior, where resources that are not used can be weakened.

Our solution works under affine systems due to the nature of exceptions explained above. 
Weakening provides a way to discard resources that are not used, and we interpret this structural rule as a process $\texttt{cancel}$ to cancel a channel. 
We add two new constructors to the type system: $\texttt{raise}$ and $\texttt{try}\ \texttt{catch}$. 
Although these constructors look similar to most exception handling mechanisms in programming languages, 
they are interpreted as processes, where the first signals an exception during the computation of processes,
and the second catches the signal and activates an additional process that handles the exception concurrently.

We briefly summarize the outline and contributions of this thesis.
In the rest of Chapter $1$, we will introduce the correlation between sequent proofs and processes, classical affine logic, and exceptions in functional programming languages.
Chapter $2$ will present the new type system we propose that deals with exceptions and its statics.
We present the model for process reduction and prove the safety of our type system in Chapter $3$.
In Chapter 4, we will demonstrate the implementation of the language interpreter and provide examples of traced processes.
Finally, Chapter $5$ will show how to represent non-exhaustive matches under our type system, with commentary on related work, limitations of the current approach, and avenues for future research.
\section{Proofs as processes} 
A sequent proof of a proposition provides its computational meaning.
We use proof terms to record the structure of proofs such that we can reconstruct the proof from its proof term.
In the context of intuitionistic linear logic, the proof term corresponds to a process. 
Below is an annotated sequent proof in intuitionistic linear logic.
\[
  x_1 : A_1, x_2 : A_2, \ldots, x_n : A_n \vdash P :: c : C
\]
where variables $x_1, x_2, \ldots, x_n, c$ represents distinct channels, propositions $A_1, A_2, \ldots, C$ represents session types \cite{Caires2010}, 
and annotation $x_i : A_i$ means the messages send along channel $x_i$ must obey the communication behavior specified by $A_i$.
Under such setting, we can regard the sequent as a process $P$ that uses all the channels in the antecedent and provides a channel in the succedent.

In proof theory, the cut allows for a composition of two separate proofs into a single proof, and correspondingly, a parallel composition of two processes connected by a channel.
\[
  \infer[\text{cut}_A]{\Gamma, \Gamma' \vdash P \mid Q :: c : C}{
    \Gamma \vdash P :: x : A
    &
    \Gamma', x : A \vdash Q :: c : C
  }
\]

The left premise represents a process $P$ that provides channel $x$, and the right premise represents another process $Q$ that uses channel $x$. 
In other words, the cut process $P$ communicates with process $Q$ through channel $x$ specified by $A$. 
The linearity of propositions ensures that the channel $x$ has only two endpoints, 
and other processes besides $P$ and $Q$ will not have access to channel $x$, 
since every channel has a distinct variable name.

The cut rule can also be understood as the spawning of a new process. 
The main thread spawns a new process $P$, splits the current resources, creates a new channel $x$,
assigns it as process $P$'s endpoint, and continues to execute the rest of the process $Q$ with the remaining resources in parallel.
\section{Classical linear logic} \label{sec:cll}
In classical logic, the judgment of entailment has the following form.
\[
  A_1, A_2, \ldots, A_n \vdash C_1, C_2, \ldots, C_m
\]
which means the conjunction of antecedents $\bigwedge_{i = 1}^n A_i$ implies the disjunction of the succedents $\bigvee_{j = 1}^m C_j$.
The negation of a proposition becomes a new primitive connective in classical logic, which distinct from intuitionistic logic where $\neg A$ is as same as $A \supset \bot$.
\[
  \infer[\text{negL}]{\Gamma, \neg A \vdash \Delta}{\Gamma \vdash A, \Delta}
  \qquad
  \infer[\text{negR}]{\Gamma \vdash \neg A, \Delta}{\Gamma, A \vdash \Delta}
\]
The behavior of negation flips around the proposition between the antecedent and the succedent. 
In other words, it assumes the contrary and tries to derive a contradiction.

Previous research has shown that classical linear logic can be viewed as $\pi$-calculus
by interpreting the negation as a dual operation on session types \cite{Wadler2012}. 
Defining the dual of a session type $A$ is $A^{\bot}$, we can rewrite the above the judgment in a single-sided form.
\[
  \vdash A_1^\bot, A_2^\bot, \ldots, A_n^\bot, C_1, C_2, \ldots, C_m
\]
Instead of cutting a proposition on different sides of inference, we cut a proposition against its dual.
\[
  \infer[\text{cut}_A]{\vdash \Delta, \Delta'}{
    \vdash A, \Delta
    &
    \vdash A^\bot, \Delta'
  }
\]
In classical logic, we know a proposition $A$ is either true or its dual proposition $A^\bot$ is true.
In the above cut rule, we can eliminate the usage of $A$ by connecting the remaining context using disjunction. 

Under the interpretation of proofs as processes, we can write the annotated two-sided judgment as follows.
\[
  x_1 : A_1, x_2 : A_2, \ldots, x_n : A_n \vdash P :: y_1 : C_1, y_2 : C_2, \ldots, y_m : C_m
\]
This judgment can be viewed as a process $P$ that communicates along channels $x_1, x_2, \ldots, x_n$
and $y_1, y_2, \ldots, y_m$, where each channel obeys its protocol requirements.
We do not distinguish whether a channel is used or provided, because we can always use the negation rule to flip the propositions.
In other word, classical logic blurs the distinction between client and server roles in concurrent communication.
The translation from classical linear logic to intuitionistic linear logic using double negation
is well studied \cite{Olivier2018}, 
thus it is possible to demonstrate the safety of this system by converting it back to intuitionistic linear logic \cite{Friedman1978}.
Such translation has practical applications, such as continuation passing style translation \cite{Appel1991}.
\section{Affine logic}
Affine logic is a substructural logic that rejects the structural rule of contraction. 
In other words, it is a form of linear logic that retains the weakening rule. 
Such logic is widely appreciated in programming languages such as Rust,
where the usage of all strongly typed channels is guaranteed to be affine \cite{Lagaillardie2022}.
There are two ways of formalizing weakening rules. 
The first formulation is implicit weakening, which modifies the original rules, 
such as the identity rule, to allow for the closure of the proof by silently discarding all propositions in the context.
\[
  \infer[\textbf{1}R]{\Gamma \vdash \textbf{1}}{}
  \qquad
  \infer[\text{identity}]{\Gamma, A \vdash A}{}
\]
Another formulation adds the explicit weakening rules.
\[
  \infer[\text{weaken}]{\Gamma, A \vdash C}{\Gamma \vdash C}
\]
Under the classical setting, we will have two weakening rules, one for the antecedent and another one for the succedent.
We can establish the equivalence of these two formulations. 
However, concerning the computational interpretation, the explicit formulation 
is more advantageous for two reasons.
Firstly, it offers explicit resource control for programmers. 
Let us annotate the explicit weakening rule as follows.
\[
  \infer[\text{weaken}]{\Gamma, x : A \vdash c : C}{
    \deduce{\Gamma \vdash c : C}{P}
  }
\]
We can interpret this rule as a process that discards the future usage of channel $x$ from resources and proceeds with process $P$. 
Discarding resources is a common practice in programming. For example, below is an implementation of a function that returns the length of a list.
\inputminted{ocaml}{code/length.ml}
In the inductive case where the list is not empty, 
the function discards the head of the list and proceeds with the remaining list. 
If we enforce linearity in this function, 
we need to rewrite the function to have the type \mintinline{ocaml}{'a list -> int * 'a list}
so that we reconstruct the list while computing its length for any future usage of the list.  

Besides the usage of dropping resources, static checking for the interpreter does not align well with implicit weakening. 
According to the implicit rule, when the process reaches its end, all channels in the context will be discarded. 
This fails to verify whether the programmer intentionally or accidentally left some resources unused.
\chapter{Type system}

In this chapter, we introduce the static semantics for our system. 
First, we list the syntax and explain the behavior of the propositions (types) included in the system.
Next, we present the process syntax and the inference rules that define the typing judgment for processes.
\section{Propositions} \label{sec:propsyntax}
The syntax of the propositions are defined in \cref{fig:propositions}.
\begin{figure}[H]
  \centering
  \begin{tabular}{c r l l}
    Propositions\ $A, B$ & $::=$ & $\textbf{1}$ & 'One', nullary case of $\otimes$ \\ 
    & $\mid$ & $\boldsymbol{\bot}$ & 'Bottom', nullary case of $\pare$  \\
    & $\mid$ & $A \otimes B$ & 'Tensor', communicates with $A$ and behaves as $B$  \\  
    & $\mid$ & $A \pare B$ & 'Par', communicates with $A$ and behaves as $B$ \\    
    & $\mid$ & $\& \{l : A_l\}_{l \in L}$ & 'With', finite choices $L$ distinguished by labels $l$ \\
    & $\mid$ & $\oplus \{l : A_l\}_{l \in L}$ & 'Plus', finite choices $L$ distinguished by labels $l$ 
   \end{tabular}
  \caption{Syntax of propositions}
  \label{fig:propositions}
\end{figure}
\begin{figure}[H]
  \centering
  \begin{tabular}{r c l l}
    $(P)^\bot$ & $\longrightarrow$ & $P^\bot$ & $P$ atom \\ 
    $\textbf{1}^\bot$ & $\longrightarrow$ & $\boldsymbol{\bot}$ & \\
    $\boldsymbol{\bot} ^ \bot$ & $\longrightarrow$ & $\textbf{1}$ & \\
    $(A \otimes B)^\bot$ & $\longrightarrow$ & $A^\bot\pare B^\bot$ &  \\  
    $(A \pare B)^\bot$ & $\longrightarrow$ & $A^\bot \otimes B^\bot$ & \\    
    $(\oplus\{l : A_l\}_{l \in L})^\bot$ & $\longrightarrow$ & $\& \{l : A_l^\bot\}_{l \in L}$ & \\ 
    $(\&\{l : A_l\}_{l \in L})^\bot$ & $\longrightarrow$ & $\oplus \{l : A_l^\bot\}_{l \in L}$ & \\
   \end{tabular}
  \caption{Dual operations on propositions}
  \label{fig:dual}
\end{figure}
The propositions can be classified into two categories: multiplicatives ($\otimes, \pare$) and additives ($\oplus, \&$). 
The behavior of each type depends on whether it is in the antecedent or the succedent of a sequent. 
Because of the dual operation in classical logic mentioned in \cref{fig:dual}, 
the behavior of a session type in the antecedent is the same as its dual in the succedent and vice versa. 
It is worth noticing that taking the dual of a proposition twice will result in the original proposition, i.e., ${(A^\bot)}^\bot = A$.

To simplify the explanation of the propositions, we discuss their logical behavior in the succedent through their inference right rules.
\begin{itemize}
  \item One
  \[
    \infer[\textbf{1}R]{\cdot \vdash \textbf{1}}{}
  \]
  The empty truth, called One, holds only if there are no resources. 
  This is the nullary case of the multiplicative conjunction.
  \item Bottom
  \[
    \infer[\boldsymbol{\bot} R]{\Gamma \vdash \boldsymbol{\bot}, \Delta}{
      \Gamma \vdash \Delta
    }
  \]
  Bottom is a nullary case of the multiplicative disjunction.
  This proposition does not contain any resources and can be dropped freely.
  \item Tensor
  \[
    \infer[\otimes R]{\Gamma_1, \Gamma_2 \vdash A \otimes B, \Delta_1, \Delta_2}{
      \Gamma_1 \vdash A, \Delta_1
      &
      \Gamma_2 \vdash B, \Delta_2
    }
  \]
  The multiplicative conjunction $A \otimes B$ is true if $A$ and $B$ are both true.
  We need to subdivide the resources, use some of them to prove $A$ the other to prove $B$. 
  \item Par
  \[
    \infer[\pare R]{\Gamma \vdash A \pare B, \Delta}{
      \Gamma \vdash A, B, \Delta
    }
  \]
  The multiplicative disjunction $A \pare B$ is true if given a refutation of $A$, $B$ is true,
  or given a refutation of $B$, $A$ is true in the current context.
  \item With
  \[
    \infer[\& R]{\Gamma \vdash \&\{l : A_l\}_{l \in L}, \Delta}{
      \Gamma \vdash A_l, \Delta
      &
      \forall l \in L
    }
  \]
  The additive conjunction $\&\{l : A_l\}_{l \in L}$ is true if for all $l \in L$, $A_l$ are true separately with the current resources.
  We need one premise for each label in $L$.
  \item Plus
  \[
    \infer[\oplus R_k]{\Gamma \vdash \oplus\{l : A_l\}_{l \in L}, \Delta}{
      \Gamma \vdash A_k, \Delta
      &
      k \in L
    }
  \]
  The additive disjunction $\oplus\{l : A_l\}_{l \in L}$ is true if there exists some $k \in L$ such that $A_k$ is true with the current resources.
  We can replace the subscript $k$ by any other labels in $L$. In other words, we have $|L|$ instances of this rule.
\end{itemize}
The linear implication $A \multimap B$ is not included in the system because it can be derived from $A^\bot \pare B$. 
We can prove this equivalence. Assume $\Gamma \vdash A \multimap B$, by the invertibility, we have $\Gamma, A \vdash B$. 
Using the dual operator, we can derive $\Gamma \vdash A^\bot, B$. By $\pare R$, we conclude $\Gamma \vdash A^\bot \pare B$. 
Since the proof is invertible, we can derive the other direction as well.

We include the inference rules of identity and cut in our system.
\[
  \infer[\text{identity}_A]{A \vdash A}{}
  \quad
  \infer[\text{cut}_A]{\Gamma_1, \Gamma_2 \vdash \Delta_1, \Delta_2}{
    \Gamma_1 \vdash A, \Delta_1
    &
    \Gamma_2, A \vdash \Delta_2
  }
\]
The identity rule closes the proof by ensuring that there is only one identical proposition on each side of the sequent. 
The cut rule allows us to split the context to prove some arbitrary propositions $A$ 
and then combine the results to prove the conclusion with the remaining context.

The structural rule of weakening is included in the system. Since we are working with a two-sided sequent, 
we have weakening rules for both the antecedent and the succedent.
\[
  \infer[\text{weaken}L]{
    \Gamma, A \vdash \Delta
  }{
    \Gamma \vdash \Delta
  }
  \quad
  \infer[\text{weaken}R]{
    \Gamma \vdash A, \Delta
  }{
    \Gamma \vdash \Delta
  }
\]
To avoid arbitrary splitting of the context and extra premises in $\otimes R$, we use the alternative version $\otimes R^*$ \cite{Caires2010}.
\[
  \infer[\otimes R^*]{\Gamma, A \vdash A \otimes B, \Delta}{
    \Gamma \vdash B, \Delta
  }
\]
We provide a simple justification for the sensibility of this rule by showing the original $\otimes R$ can be derived from $\otimes R^*$ and vice versa.
\begin{itemize}
  \item Assume we have a derivation $\mathcal{D}_1$ for $\Gamma_1 \vdash A, \Delta_1$ and $\mathcal{D}_2$ for $\Gamma_2 \vdash B, \Delta_2$.
  We can create a derivation for $\Gamma_1, \Gamma_2 \vdash A \otimes B, \Delta_1, \Delta_2$ without using $\otimes R$ rule as the following:
  \[
    \infer[\text{cut}_A]{\Gamma_1, \Gamma_2 \vdash A \otimes B, \Delta_1, \Delta_2}{
      \deduce{\Gamma_1 \vdash A, \Delta_1}{\mathcal{D}_1}
      &
      \infer[\otimes R^*]{\Gamma_2, A \vdash A \otimes B, \Delta_2}{
        \deduce{\Gamma_2 \vdash B, \Delta_2}{\mathcal{D}_2}
      }
    }
  \]
  \item Assume we have a derivation $\mathcal{D}$ for $\Gamma \vdash B, \Delta$.
  We can create a derivation for $\Gamma, A \vdash A \otimes B, \Delta$ without using $\otimes R^*$ rule as the following:
  \[
    \infer[\otimes R]{\Gamma, A \vdash A \otimes B, \Delta}{
      \infer[\text{identity}_A]{A \vdash A}{}
      &
      \deduce{\Gamma \vdash B, \Delta}{\mathcal{D}}
    }
  \]
\end{itemize}
We can rewrite $\pare L^*$ rule accordingly and justify its equivalence with the original $\pare L$. 
\[
  \infer[\pare L^*]{\Gamma, A \pare B \vdash A, \Delta}{
    \Gamma \vdash B, \Delta
  }
\]
\section{Processes}
In this section, we will annotate the proofs with proof terms and interpret them as processes.
Moreover, we will introduce our exception handling mechanism in our system. 
We first present the syntax of the processes in \cref{fig:processes}.
\begin{figure}[H]
  \centering
  \begin{tabular}{r r r l}
    Messages & $M$ & $::=$ & $()$ \\
    & & $\mid$ & $l$ \\
    & & $\mid$ & $x$ \\  
    Continuations & $K$ & $::=$ & $(() \Rightarrow P)$ \\    
    & & $\mid$ & $(l \Rightarrow P_l)_{l \in L}$ \\
    & & $\mid$ & $(x \Rightarrow P(x))$ \\
    Processes & $P, Q$ & $::=$ & $\send{x}{M}$ \\
    & & $\mid$ & $\recv{x}{K}$ \\
    & & $\mid$ & $\fwd{y}{x}$ \\
    & & $\mid$ & $\cancel{x}$ \\
    & & $\mid$ & $\spawn{P}{Q}{x}$ \\
    & & $\mid$ & $\craise{M}$ \\
    & & $\mid$ & $\trycatch{P}{Q}{x}$ \\
   \end{tabular}
  \caption{Syntax of processes}
  \label{fig:processes}
\end{figure}
We separate the terms into three categories: \textit{messages}, \textit{continuations}, and \textit{processes}. 
Variables are used to represent channels and strings are used to represent labels. 
We require the channels to have distinct names. 
The information passed through channels can be either a unit message $()$, 
a label $l$, or a channel $x$. The continuation specifies the behavior of the process after receiving a message. 
Correspondingly, there are three kinds of continuations. 
$(() \Rightarrow P)$ is a unit continuation that waits for a unit message and continues with process $P$. 
$(l \Rightarrow P_l)_{l \in L}$ is a branching continuation that selects to execute process $P_l$ based on the label $l$ it receives. 
In other words, it has prepared the same number of processes as the number of labels in $L$. $(x \Rightarrow P(x))$ is a continuation 
that waits for a channel $x$ and continues with process $P(x)$. We write $P(x)$ instead of $P$ to indicate that the process $P$ depends on the channel $x$.

From the description above, we provide an intuition of how processes interact with each other. 
Imagine a segment where one endpoint outputs a message and passes it to the other endpoint, 
which works as a continuation that waits for the message through this segment.
We can see that each message has its own corresponding continuation. 
This means that if the message passing through the segment is a label while the continuation is waiting for a channel, 
the interaction will be stuck and cannot proceed. 
We can use propositions as session types introduced in \cref{sec:propsyntax} to restrict channel behavior. 
More details on this observation will be discussed in the operational semantics.

We present the annotated inference rules in \cref{fig:static}, where proof terms are interpreted as processes. 
The judgment has the form $\judge{\Gamma}{P}{\Delta}{\Omega}$, 
which means the process $P$ communicates along the channels in $\Gamma$ and $\Delta$ and has an exception handler $\Omega$. 
The usage of the singleton context $\Omega$ is explained in \cref{sec:exnproc}.
\begin{figure}
  \begin{rules}
    \defrule[\textbf{1}$R$][oneR]{}{\judge{\cdot}{\send{x}{()}}{x : \textbf{1}}{\Omega}}
    \qquad
    \defrule[\textbf{1}$L$][oneL]{\judge{\Gamma}{P}{\Delta}{\Omega}}{
      \judge{\Gamma, x : \textbf{1}}{\recv{x}{(() \Rightarrow P)}}{\Delta}{\Omega}
    }\\
    \defrule[$\boldsymbol{\bot}R$][botR]{\judge{\Gamma}{P}{\Delta}{\Omega}}{
      \judge{\Gamma}{\recv{x}{(() \Rightarrow P)}}{x : \boldsymbol{\bot}, \Delta}{\Omega}
    }
    \qquad
    \defrule[$\boldsymbol{\bot}L$][botL]{}{\judge{x : \boldsymbol{\bot}}{\send{x}{()}}{\cdot}{\Omega}}\\
    \defrule[$\otimes R^*$][tensorR]{\judge{\Gamma}{P}{x : B, \Delta}{\Omega}}{
      \judge{\Gamma, y : A}{\send{x}{y}; P}{x : A \otimes B, \Delta}{\Omega}
    }
    \qquad
    \defrule[$\otimes L$][tensorL]{\judge{\Gamma, x : B, y : A}{P}{\Delta}{\Omega}}{
      \judge{\Gamma, x : A \otimes B}{\recv{x}{(y \Rightarrow P(y))}}{\Delta}{\Omega}
    }\\
    \defrule[$\pare R$][parR]{\judge{\Gamma}{P}{\Delta}{x : B, y : A, \Omega}}{
      \judge{\Gamma}{\recv{x}{(y \Rightarrow P(y))}}{x : A \pare B, \Delta}{\Omega}
    }
    \qquad
    \defrule[$\pare L^*$][parL]{\judge{\Gamma, x : B}{P}{\Delta}{\Omega}}{
      \judge{\Gamma, x : A \pare B}{\send{x}{y}; P}{y : A, \Delta}{\Omega}
    }\\
    \defrule[$\oplus R_k$][orR]{\judge{\Gamma}{P}{A_k}{\Omega} \\ k \in L}{
      \judge{\Gamma}{\send{x}{k}; P}{x : \oplus\{l : A_l\}_{l \in L}, \Delta}{\Omega}
    }
    \quad
    \defrule[$\oplus L$][orL]{\judge{\Gamma, x : A_l}{P_l}{\Delta}{\Omega} \\ (\forall l \in L)}{
      \judge{\Gamma, x : \oplus\{l : A_l\}_{l \in L}}{\recv{x}{(l \Rightarrow P_l)_{l \in L}}}{\Delta}{\Omega}
    }\\
    \defrule[$\& R$][withR]{\judge{\Gamma, x : A_l}{P_l}{\Delta}{\Omega} \\ (\forall l \in L)}{
      \judge{\Gamma, x : \&\{l : A_l\}_{l \in L}}{\recv{x}{(l \Rightarrow P_l)_{l \in L}}}{\Delta}{\Omega}
    }
    \quad
    \defrule[$\& L_k$][withL]{\judge{\Gamma, x : A_k}{P}{\Delta}{\Omega} \\ k \in L}{
      \judge{\Gamma, x : \&\{l : A_l\}_{l \in L}}{\send{x}{k}; P}{\Delta}{\Omega}
    }\\
    \defrule[weakenR][weakenR]{\judge{\Gamma}{P}{\Delta}{\Omega}}{
      \judge{\Gamma}{\cancel{x}; P}{x : A, \Delta}{\Omega}
    }
    \qquad
    \defrule[weakenL][weakenL]{\judge{\Gamma}{P}{\Delta}{\Omega}}{
      \judge{\Gamma, x : A}{\cancel{x}; P}{\Delta}{\Omega}
    }
    \qquad
    \defrule[$\text{identity}_A$][identity]{}{
      \judge{y : A}{\fwd{x}{y}}{x : A}{\Omega}
    }
    \\
    \defrule[$\text{cut}_A$][cut]{\judge{\Gamma_1}{P(x)}{x : A, \Delta_1}{\cdot} \\ \judge{\Gamma_2, x : A}{Q(x)}{\Delta_2}{\Omega}}{
      \judge{\Gamma_1, \Gamma_2}{\spawn{P}{Q}{x}}{\Delta_1, \Delta_2}{\Omega}
    }
    \\
    \defrule[raise][raise]{\judge{\Gamma}{P}{\Delta}{\cdot}}{
      \judge{\Gamma}{\craise{P}}{\Delta}{x : \text{exn}}
    }\\
    \defrule[$\text{trycatch}_A$][trycatch]{
      \judge{\Gamma_1}{P(y)}{y : A, \Delta_1}{x : \text{exn}}\\
      \judge{\Gamma_2, x : \text{exn}, y : A}{\text{erecv}\ x\ Q(y)}{\Delta_2}{\Omega}
    }{
      \judge{\Gamma_1, \Gamma_2}{\trycatch{P}{Q}{y}}{\Delta_1, \Delta_2}{\Omega}
    }
  \end{rules}
  \caption{Static semantics of the type system}
  \label{fig:static}
\end{figure} 
We first introduce the standard processes and explain how information flows through channels. 
Processes of $\textbf{send}$ and $\textbf{recv}$ are elementary processes. 
$\send{x}{M}$ sends a message $M$ along channel $x$, and $\recv{x}{K}$ receives a message from channel $x$ 
and continues with the continuation $K$. Whether a process sends or receives a message depends on the polarity of the connective. 
Positive connectives, whose right rule is not invertible, will send a message in their right rule and receive a message in their left rule. 
The intuition is that non-invertible rules always make a choice, while invertible rules do not contain any extra information.

The proposition restricts the message type a channel can send or receive. 
A channel of type $\textbf{1}$ or $\boldsymbol{\bot}$ can only send or receive a unit message, 
respectively. In logic systems, $\textbf{1}$ represents the empty truth, and $\boldsymbol{\bot}$ represents the empty falsehood. 
Therefore, a unit message is also called an empty message since it does not contain any useful information. 
An analogy can be drawn from a unit message to computation suspension in functional programming. Under call-by-value settings, 
an expression $e$ needs to be eagerly evaluated before it can be involved in future computation. 
However, if we replace $e$ by $\lambda (x : \texttt{unit}. e)$, then the computation of $e$ is suspended since a function is already a value. 
We can retrieve the computation by applying the function to a unit value $()$. 
In the message-passing setting, $\recv{x}{(() \Rightarrow P)}$ is a "suspended" process that waits for a unit message sent through channel $x$.

A channel of product type $\otimes$ and $\pare$ can send or receive a channel, and its type evolves accordingly. 
For instance, in the \ruleref{tensorR} rule, the process $\send{x}{y}; P$ sends a channel $y$ along channel $x$ and continues with process $P$. 
Before sending the channel $y$, the channel $x$ has type $A \otimes B$. 
After sending $y$ of type $A$, the channel $x$ evolves to type $B$. The last message corresponds to choice types $\oplus$ and $\&$. 
A choice type is a collection of types distinguished by labels. 
For instance, the type \texttt{bool} can be written as $\oplus\{\text{true} : \textbf{1}, \text{false} : \textbf{1}\}$, 
a choice type of two labels true and false with unit types. $\send{x}{l}$ sends a label $l$ along channel $x$. 
This can be viewed as a process that makes a choice to select label $l$ from all the possible label collections $L$. 
We add a subscript $k$ as a label to the \ruleref{orR} rule to indicate that the process chooses $k$. 
The type of the channel evolves from choice type to the corresponding type of label $k$. 
$\recv{x}{(l \Rightarrow P_l)}$ provides a branching continuation that selects one branch to execute based on the label it receives. 
We write $\forall l \in L$ to indicate that the process has prepared a process for each label in $L$. 
In other words, if there is some label missing in the branching, the process will panic and do not know how to proceed. 
However, we can exploit this feature by including non-exhaustive matches in our language, which will be discussed in \cref{sec:nonexhaust}.

Now we discuss the structural rules of our system. The weakening rule is represented by the channel cancellation process $\cancel{x}$. 
Although we have two different weakening rules: $\ruleref{weakenL}$ and $\ruleref{weakenR}$, we do not distinguish them syntactically. 
The process $\cancel{x}$ discards the channel $x$ from the context and continues with process $P$ under the remaining context. 
The $\ruleref{identity}$ rule is represented by the process $\fwd{y}{x}$, which passes the information from channel $y$ to channel $x$. 
The cut rule spawns a child process $P$ with a newly created private channel $x$ and continues with the parent process $Q$ under the remaining context. 
The split of the exception handling context and the remaining rules about exceptions are discussed in the next section.
\section{Exception processes}\label{sec:exnproc}
We first examine how exceptions are raised and handled in common functional programming languages. 
Below is a function that returns the division of two numbers optionally. In other words,
if there is no division by zero, the function returns the division of two numbers.
Otherwise, it prints a message to console and returns none. 
\inputminted{ocaml}{code/div.ml} 
An important observation is sequential execution in computation. 
Whether the print statement will be executed is not determined until the division is evaluated. 
We adapt such an idea in our exception handling mechanism. 
The execution of an exception handling process requires the execution of the main process, 
and we use $\Omega$ to store the channels that communicate between the main process and the exception handling process.
$\Omega$ is a singleton context, 
which means it contains at most one channel. If there are no channels in $\Omega$, 
this means process $P$ does not have any exception handling mechanism. 
Then, if $P$ raises an exception, it will be an uncaught exception. 
\[
  \Omega = \cdot \mid x : \text{exn}
\]
The channel in $\Omega$ has type $\text{exn}$, which is defined as the following:
\[
  \text{exn} = \oplus\{\text{act} : \textbf{1}, \text{sil} : \textbf{1}\}
\]
As described before, a channel of type $\text{exn}$ sends and receives a label of either \texttt{act} or \texttt{sil}. 
\texttt{act} label represents activation of the exception handling process when an exception is raised.
Conversely, \texttt{sil} label represents the drop of the exception handling process when the process finished executing without any exceptions.

With enough introduction, we can look at the structure of $\ruleref{trycatch}$. 
It creates a channel $y$ and splits the resources to execute the main process $P$.
Meanwhile, a new channel $x$ of type \texttt{exn} is created and assigned to $P$.
The process \texttt{erecv} is a derived form which is defined by the following:
\begin{align*}
  \Gamma \vdash \text{erecv}\ x\ Q(y) :: \Delta ; \Omega \triangleq \Gamma \vdash \recv{x}{(\text{act} &\Rightarrow \recv{x}{(() \Rightarrow Q(y))} \\ 
  \mid \text{sil} &\Rightarrow \recv{x}{(() \Rightarrow \cancel{y}; \cancel{\Gamma}; \cancel{\Delta})})} :: \Delta; \Omega
\end{align*}
It waits for a label sent through channel $x$. If the label is \texttt{act}, 
which means an exception is raised by its main process, 
it starts to execute the process $Q(y)$ using the remaining context and the original exception handling context. 
On the other hand, if the main process finishes execution without any exceptions, 
a \texttt{sil} label will lead to a branch of cancelling all resources prepared for exception handling. 
The exception handling context is inherited from the original process.

Now let's revisit the body of the division function to see how exceptions are raised. 
The division \texttt{a / b} is a partial function that will raise an exception when $b = 0$. 
The exception is characterized by the exception constructor \texttt{Failure} with a message attached to it. 
In the example above, we do not utilize the information stored in the exception.
We follow the same structure in our system; instead of raising an exception with a value, 
we raise a \textit{process} as described in $\ruleref{raise}$. $\craise{P}$ raises an exception and continues to execute with process $P$. 
Currently, we require the exception to be caught by the exception handling process. This invariant is enforced by requiring $\Omega$ to be non-empty. 
However, this restriction can be relaxed, as uncaught exceptions are common in programming languages. We explore this feature in \cref{sec:uncaught}.

\chapter{Runtime semantics}
We model the execution of the program as transitions between states. 
Each state consists of a configuration and a cancelled set. 
We adapt previous work by regarding the configuration as a multiset whose reduction follows linear inference \cite{Cervesato2009}, 
while the cancelled set records the channels that are cancelled during the execution globally. 
We also formalize recursion to make the program more expressive. 
After that, we prove the safety theorems of the system by showing that well-typed configurations will not get stuck, 
and after reduction, the configuration will still be well-typed.
\section{Configuration}

To formalize the runtime semantics, we can view each process as an individual object. 
The start of the program can be viewed as a configuration with a single object. 
During the execution of the program, new processes will be spawned, 
adding new process objects to the configuration. We define the configuration $\config$ in \cref{fig:config}.
\begin{figure}[H]
  \centering
  \begin{tabular}{r r r l l}
    Configuration & $\config$ & $::=$ & $\cdot$ & empty configuration \\
    & & $\mid$ & $\config_1, \config_2$ & join configuration \\
    & & $\mid$ & $\procObj{\Gamma}{\Delta}{\Omega}{P}$ & process object
   \end{tabular}
  \caption{Syntax of configuration}
  \label{fig:config}
\end{figure}
The empty configuration is an empty multiset that does not contain any process object.
A single process object of form $\procObj{\Gamma}{\Delta}{\Omega}{P}$ represents a process $P$
communicates along the channels in $\Gamma$ and $\Delta$ and has an exception handling context $\Omega$.
During the transition of the program, the meta variables in the process object may change accordingly.
Lastly, the join combines two configuration into one configuration.

To avoid the situation of bad programs, where one channel receives a label message and has a unit continuation, 
we establish the typing judgment for configuration of form $\Phi \vdash \config :: \Phi'$. The configuration $\config$
uses channels in $\Phi$ and provides channels $\Phi'$. For instance, if a configuration $C$ uses channel $a : A$ and provides channel $b : B$,
then $\Phi, a : A \vdash \config :: b : B, \Phi$ holds. We provide the relevant rules in \cref{fig:configtyping}.
\begin{figure}[H]
  \centering
  \begin{rules}
    \defrule[empty][config-empty]{}{
      \Phi \vdash \cdot :: \Phi
    }
    \qquad
    \defrule[join][config-join]{
      \Phi \vdash \config_1 :: \Phi' \\ \Phi' \vdash \config_2 :: \Phi''
    }{
      \Phi \vdash \config_1, \config_2 :: \Phi''
    }\\
    \defrule[object][config-object]{}{
      \Phi, \Gamma \vdash \procObj{\Gamma}{\Delta}{\Omega}{P} :: \Delta, \Omega, \Phi
    }
  \end{rules}
  \caption{Typing judgment of configuration}
  \label{fig:configtyping}
\end{figure}
$\ruleref{config-empty}$ states that an empty configuration does not use any channels and provides the same channels.
We add an arbitrary context $\Phi$ on both sides to generalize the $\ruleref{config-object}$ rule, since there may be channels that are not used by process $P$.
$\ruleref{config-join}$ combines two configurations $\config_1$ and $\config_2$ into one configuration $\config$ by some certain order.
This may contradict with the intuition that the configuration is an unordered set where $\config_1, \config_2$ should be as same as $\config_2, \config_1$.
Here, we require that there exists an ordering of the configuration such that it is well-typed.
Such ordering is not unique, apparently. Consider an example where $\config_1 = \procObj{\cdot}{a : A}{\cdot}{P}$ and $\config_2 = \procObj{b : B, c : C}{\cdot}{\cdot}{Q}$.
We can join these two configurations in two ways: $\config = \config_1, \config_2$ and $\config = \config_2, \config_1$ where $b : B, c : C \vdash \config :: a : A$.
Using the \ruleref{config-object}, we can find such $\Phi' = a : A, b : B, c : C$ for the first way and $\Phi' = \cdot$ for the second way.
However, if we change $\config_2$ into $\procObj{a : A, b : B}{\cdot}{\cdot}{Q}$, the overall configuration $b : B \vdash \config :: \cdot$ still type checks, 
but the ordering is unique.
It cannot be the case that $\config = \config_2, \config_1$, and the reason for that is because $\config_1$ provides channel $a$ that is used by $\config_2$.
By this observation, two configurations can be swapped if none of the channels provided by the first configuration are used by the second configuration.

Besides the configuration, we also need a globally defined set to store the channels that are cancelled during the execution, call it $\cancelSet$.
The main reason why we need to keep track of this set is because the cancellation of a channel may affect the execution of other processes.
Every channel can be viewed as a segment that has two endpoints. In the original execution, one endpoint will send a message and the other endpoint is a continuation that waits for this message.
However, if one endpoint is cancelled, the other endpoint should also be cancelled accordingly. 
We call this procedure \textit{cancellation propagation}.

To conclude, the state of the computation is a pair of current configuration and cancelled set $\langle \config, \cancelSet \rangle$.
\section{Recursion}
Recursion is a very practical tool in programming, 
and we also want such a feature in our system. However, the formalization of recursion has little to do with logics. 
We achieve such equirecursion by having a signature $\Sigma_{\text{decl}}$ and a structure $\Sigma_{\text{defn}}$, 
whose syntax is defined in \cref{fig:syntaxsig}.
\begin{figure}[H]
  \centering
  \begin{tabular}{r r l}
    $\Sigma_{\text{decl}}$ & $::=$ & $\cdot$ \\
    & $\mid$ & $t$ \\
    & $\mid$ & $p : (X, Y)$ \\
    & $\mid$ & $\Sigma_{\text{decl}1}, \Sigma_{\text{decl}2}$ \\  
    $\Sigma_{\text{defn}}$ & $::=$ & $\cdot$ \\
    & $\mid$ & $t = A$ \\
    & $\mid$ & $p (y_1, y_2, \ldots, y_m)[x_1, x_2, \ldots, x_n]= P$ \\
    & $\mid$ & $\Sigma_{\text{defn}1}, \Sigma_{\text{defn}2}$
    \end{tabular}
  \caption{Syntax of signature and structure}
  \label{fig:syntaxsig}
\end{figure}
A type declaration $t$ states that the identifier $t$ refers to a type, while
a process declaration $p : (X, Y)$ specifies a process identifier $p$ whose input channel types are stored in a list $X$
and output channel types in a list $Y$. 
Such a signature can be determined when scanning through the whole program. 
We want to ensure that all the definitions in the program are well-defined based on the declarations. 
This structure records both type and process definitions. A type definition has the form $t = A$, 
where $t$ is a type identifier and $A$ is a proposition. A process definition has the form $p (y_1, y_2, \ldots, y_m) [x_1, x_2, \ldots, x_n] = P$. 
The identification includes a process name $p$, a list of output channels $y_1, y_2, \ldots, y_m$, 
and a list of input channels $x_1, x_2, \ldots, x_n$. The process such identification represents is $P$. 
We use the judgment $\Sigma_{\text{decl}} \vdash \Sigma_{\text{defn}} \textbf{ struct}$ to represent that $\Sigma_{\text{defn}}$ 
is a valid structure given all the declarations in $\Sigma_{\text{decl}}$. We present the rules for signatures in \cref{fig:sig}. 
The judgments for well-formed types $\Sigma_{\text{decl}} \vdash A \textbf{ type}$ 
and well-formed processes $\Sigma_{\text{decl}} \vdash P \textbf{ proc}$ can be defined by looking at the signature, 
and thus we omit the rules here.
\begin{figure}[H]
  \centering
  \begin{rules}
    \defrule[empty][sig-empty]{}{
      \Sigma_{\text{decl}} \vdash \cdot \textbf{ struct}
    }
    \qquad
    \defrule[typedef][sig-join]{
      \Sigma_{\text{decl}} \vdash \Sigma_{\text{defn}} \textbf{ struct} \\ \Sigma_{\text{decl}} \vdash A \textbf{ type}
    }{
      \Sigma_{\text{decl}} \vdash \Sigma_{\text{defn}}, t = A \textbf{ struct}
    }\\
    \defrule[procdef][sig-object]{
      \Sigma_{\text{decl}} \vdash \Sigma_{\text{defn}} \textbf{ struct} \\ \Sigma_{\text{decl}} \vdash P(x_1,x_2,\ldots,x_n,y_1,y_2,\ldots,y_m) \textbf{ proc}
    }{
      \Sigma_{\text{decl}} \vdash \Sigma_{\text{defn}}, p (y_1, y_2, \ldots, y_m) [x_1, x_2, \ldots, x_n] = P \textbf{ struct}
    }
  \end{rules}
  \caption{judgment of well-formed structure}
  \label{fig:sig}
\end{figure}
We present some examples of recursive types that will be used in future examples.
\begin{itemize}
  \item Natural number \texttt{nat}
  \[
    \texttt{nat} \triangleq \oplus\{\text{zero} : \textbf{1}, \text{succ} : \texttt{nat}\}
  \]
  The definition of natural number is a choice type of two labels \texttt{zero} and \texttt{succ},
  where \texttt{zero} represents the number $0$ and \texttt{succ} represents the successor of a natural number.
  This looks similar to the inductive type $\mu(t.1 + t)$.
  \item List of natural numbers \texttt{list}
  \[
    \texttt{list} \triangleq \oplus\{\text{nil} : \textbf{1}, \text{cons} : \texttt{nat} \otimes \texttt{list}\}
  \]
  List of natural numbers is also a choice type of two labels \texttt{nil} and \texttt{cons}.
  In the \texttt{cons} label, it contains multiplicative product of \texttt{nat} and \texttt{list}.
  To ensure \texttt{list} is well-defined, we need to have a type definition for \texttt{nat} in the signature. 
\end{itemize}
To utilize recursing processes, we add a new process expression \textbf{call} to activate another process in \cref{fig:extended}.
A process can call itself to achieve self recursion.
\begin{figure}[H]
  \centering
  \begin{tabular}{r r r l}
    Processes & $P, Q$ & $::=$ & $\ldots$ \\
    & & $\mid$ & $\call{p}{y_1, y_2, \ldots, y_m}{x_1, x_2, \ldots, x_n}$
  \end{tabular}
  \begin{rules}
    \defrule[call][call]{
      \Sigma_{\text{decl}} \vdash p (y_1, y_2, \ldots, y_m) [x_1, x_2, \ldots, x_n] = P \textbf{ struct} \\
      p : ([A_1, A_2, \ldots A_n], [C_1, C_2, \ldots C_m]) \in \Sigma_{\text{decl}}
    }{
      \judge{\Gamma}{\call{p}{y_1, y_2, \ldots, y_m}{x_1, x_2, \ldots, x_n}}{\Delta}{\Omega}
    }\\
    \text{where } \Gamma = x_1 : A_1, x_2 : A_2, \ldots, x_n : A_n \text{ and } \Delta = y_1 : C_1, y_2 : C_2, \ldots, y_m : C_m
  \end{rules}
  \caption{Extended syntax and static semantics of the type system}
  \label{fig:extended}
\end{figure}
The \textbf{call} process looks up the signature $\Sigma_\text{decl}$ and finds the process defined by identifier $p$.
Moreover, we need to check the types for each variable matches with the signature of the process.
There should be no future processes after the \textbf{call}, thus we require process $P$ takes all the channels in $\Gamma$ and $\Delta$.
The exception handling context $\Omega$ is inherited from the original process. 
\section{Reduction}
In future discussions, we will distinguish channels using $a,b,c,\ldots$ for allocated ones 
and use $x,y,z,\ldots$ for ones are variables that require substitution during the execution. 
For instance, $\spawn{P}{Q}{a}$ should not be allowed since channel $a$ should be a variable instead of a created channel. 
Similarly, $\cancel{x}$ is invalid since we cannot cancel a channel that is not allocated.

The reduction of the configuration is based on linear inference. 
New process objects are created when a new process is spawned. 
Correspondingly, process objects may be destroyed when the process is finished or evolves to another process. 
A reduction step is represented by $\langle \config; \cancelSet \rangle \longrightarrow \langle \config'; \cancelSet' \rangle$. 
The reduction rules only examine parts of the configuration. The untouched parts are preserved in the new configuration. 
We first present the standard reduction rules without exceptions in \cref{fig:stdreduction}.

Most of the standard rules represent message reduction. 
For instance, in \stepref{label-reduction-r}{label-r}, one process sends a label $k$ through channel $a$, and in another process, 
it waits for a label from $a$ and passes it to a branching continuation. Therefore, two processes can make progress simultaneously. 
As the first process continues to execute the remaining process $P$, the second process chooses process $P_k$ to execute. 
By the duality of the propositions, each reduction has two versions of rules, one for the right rule and one for the left rule.

In the \stepref{forward}{linking} rule, the process $\fwd{c}{a}$ passes information from channel $a$ to channel $c$. 
We achieve this effect by replacing all usages of channel $a$ by channel $c$ in the continuation process. 
Since the invariant that every channel has two endpoints holds, we know there is only one such process where we need to do the substitution. 
The \stepref{spawn}{spawn} rule splits the original object into two process objects. The first object contains the new process $P$, 
and the second object contains the original process $Q$. A new channel $a$ is created and put into the relevant context. 
We require that the channel $a$ is globally fresh to avoid naming conflicts. Moreover, the contexts are split based on the metavariables in each process. 
According to the static rules, there must be a valid splitting of the context that maintains the typing of the configuration. 
\begin{figure}[H]
  \begin{alignat}{2}
    \label{unit-reduction-r} \textsc{[unit-r]} & ~ 
    \Braket{
      \begin{array}{l}
        \procObj{\cdot}{a : \textbf{1}}{\Omega_1}{\send{a}{()}} \\
        \procObj{\Gamma, a : \textbf{1}}{\Delta}{\Omega_2}{\recv{a}{(() \Rightarrow P)}}
      \end{array}
      ; \cancelSet
    } \tag*{} \\ ~ \longrightarrow & ~ 
    \Braket{
      \begin{array}{l}
        \procObj{\cdot}{\cdot}{\Omega_1}{\cdot} \\
        \procObj{\Gamma}{\Delta}{\Omega_2}{P}
      \end{array}
      ; \cancelSet
    } \tag*{} \\
    \label{unit-reduction-l} \textsc{[unit-l]} & ~ 
    \Braket{
      \begin{array}{l}
        \procObj{a : \boldsymbol{\bot}}{\cdot}{\Omega_1}{\send{a}{()}} \\
        \procObj{\Gamma}{a : \boldsymbol{\bot}, \Delta}{\Omega_2}{\recv{a}{(() \Rightarrow P)}}
      \end{array}
      ; \cancelSet
    } \tag*{} \\ ~ \longrightarrow & ~ 
    \Braket{
      \begin{array}{l}
        \procObj{\cdot}{\cdot}{\Omega_1}{\cdot} \\
        \procObj{\Gamma}{\Delta}{\Omega_2}{P}
      \end{array}
      ; \cancelSet
    } \tag*{} \\
    \label{channel-reduction-r} \textsc{[channel-r]} & ~ 
    \Braket{
      \begin{array}{l}
        \procObj{\Gamma_1, a : A}{c : A\otimes B, \Delta_1}{\Omega_1}{\send{c}{a}; P} \\
        \procObj{\Gamma_2, c : A \otimes B}{\Delta_2}{\Omega_2}{\recv{c}{(x \Rightarrow P(x))}}
      \end{array}
      ; \cancelSet
    } \tag*{} \\ ~ \longrightarrow & ~ 
    \Braket{
      \begin{array}{l}
        \procObj{\Gamma_1}{c : B, \Delta_1}{\Omega_1}{P} \\
        \procObj{\Gamma_2, c : B}{\Delta_2}{\Omega_2}{P(a)}
      \end{array}
      ; \cancelSet 
    } \tag*{} \\
    \label{channel-reduction-l} \textsc{[channel-l]} & ~ 
      \Braket{
        \begin{array}{l}
          \procObj{\Gamma_1, c : A \pare B}{a : A, \Delta_1}{\Omega_1}{\send{c}{a}; P} \\
          \procObj{\Gamma_2}{c : A \pare B, \Delta_2}{\Omega_2}{\recv{c}{(x \Rightarrow P(x))}}
        \end{array}
        ; \cancelSet
      } \tag*{} \\ ~ \longrightarrow & ~ 
      \Braket{
        \begin{array}{l}
          \procObj{\Gamma_1}{c : B, \Delta_1}{\Omega_1}{P} \\
          \procObj{\Gamma_2, c : B}{\Delta_2}{\Omega_2}{P(a)}
        \end{array}
        ; \cancelSet
    } \tag*{} \\
    \label{label-reduction-r} \textsc{[label-r]} & ~ 
      \Braket{
        \begin{array}{l}
          \procObj{\Gamma_1}{a : \oplus\{l : A_l\}_{l \in L}, \Delta_1}{\Omega_1}{\send{a}{k}; P} \\
          \procObj{\Gamma_2, a : \oplus\{l : A_l\}_{l \in L}}{\Delta_2}{\Omega_2}{\recv{a}{(l \Rightarrow P_l)_{l \in L}}}
        \end{array}
        ; \cancelSet
      } \tag*{} \\ ~ \longrightarrow & ~ 
      \Braket{
        \begin{array}{l}
          \procObj{\Gamma_1}{a : A_k, \Delta_1}{\Omega_1}{P} \\
          \procObj{\Gamma_2, a : A_k}{\Delta_2}{\Omega_2}{P_k}
        \end{array}
        ; \cancelSet
    } \tag*{} \\
    \label{label-reduction-l} \textsc{[label-l]} & ~ 
      \Braket{
        \begin{array}{l}
          \procObj{\Gamma_1, a : \&\{l : A_l\}_{l \in L}}{\Delta_1}{\Omega_1}{\send{a}{k}; P} \\
          \procObj{\Gamma_2}{a : \&\{l : A_l\}_{l \in L}, \Delta_2}{\Omega_2}{\recv{a}{(l \Rightarrow P_l)_{l \in L}}}
        \end{array}
        ; \cancelSet
      } \tag*{} \\ ~ \longrightarrow & ~ 
      \Braket{
        \begin{array}{l}
          \procObj{\Gamma_1, a : A_k}{\Delta_1}{\Omega_1}{P} \\
          \procObj{\Gamma_2}{a : A_k, \Delta_2}{\Omega_2}{P_k}
        \end{array}
        ; \cancelSet
    } \tag*{} \\
    \label{forward} \textsc{[linking]} & ~ 
      \Braket{
        \begin{array}{l}
          \procObj{a : A}{c : A}{\Omega_1}{\fwd{c}{a}} \\
          \procObj{\Gamma}{a : A, \Delta}{\Omega_2}{P(a)}
        \end{array}
        ; \cancelSet
      } \tag*{} \\ ~ \longrightarrow & ~ 
      \Braket{
        \begin{array}{l}
          \procObj{\cdot}{\cdot}{\Omega_1}{\cdot} \\
          \procObj{\Gamma}{c : A, \Delta}{\Omega_2}{P(c)}
        \end{array}
        ; \cancelSet
    } \tag*{} \\
    \label{spawn} \textsc{[spawn]} & ~ 
      \Braket{
        \begin{array}{l}
          \procObj{\Gamma_1, \Gamma_2}{\Delta_1, \Delta_2}{\Omega}{\spawn{P}{Q}{x}}\\
          \judge{\Gamma_1}{P(x)}{x : A, \Delta_1}{\cdot}\\
          \judge{\Gamma_2, x : A}{Q(x)}{\Delta_2}{\Omega}
        \end{array}
        ; \cancelSet
      } \tag*{} \\ ~ \longrightarrow & ~ 
      \Braket{
        \begin{array}{l}
          \procObj{\Gamma_1}{a : A, \Delta_1}{\cdot}{P(a)} \\
          \procObj{\Gamma_2, a : A}{\Delta_2}{\Omega}{Q(a)}
        \end{array}
        ; \cancelSet
    } \tag*{} \\
    \label{call} \textsc{[call]} & ~ 
      \Braket{
        \begin{array}{l}
          \procObj{\Gamma}{\Delta}{\Omega}{\call{p}{y_1, y_2, \ldots, y_m}{x_1, x_2, \ldots, x_n}}
        \end{array}
        ; \cancelSet
      } \tag*{} \\ ~ \longrightarrow & ~ 
      \Braket{
        \begin{array}{l}
          \procObj{\Gamma}{\Delta}{\Omega}{P}
        \end{array}
        ; \cancelSet
    } \tag*{} \\
    \label{finish} \textsc{[end]} & ~ 
      \Braket{
        \begin{array}{l}
          \procObj{\cdot}{\cdot}{\cdot}{\cdot}
        \end{array}
        ; \cancelSet
      } \tag*{} \\ ~ \longrightarrow & ~ 
      \Braket{
        \begin{array}{l}
          \cdot
        \end{array}
        ; \cancelSet
    } \tag*{}
  \end{alignat}
  \raggedleft
  \caption{Standard reductions of configuration}
  \label{fig:stdreduction}
\end{figure}
In the \stepref{call}{call} rule, we assume the signature is well-formed, thus there exists a process declaration for $p$. 
We find such a definition $p (y_1, y_2, \ldots, y_m) [x_1, x_2, \ldots, x_n] = P$ and execute the process $P$. 
We can drop a process object when the process is finished and use $\cdot$ to represent an empty process. 
It must be the case for any empty process, there are no remaining channels unused.
The formalization is referred to the \stepref{finish}{end} rule.

Now let's examine the reduction rules in channel cancellation as listed in \cref{fig:cancelreduction}.
The cancellation process removes a channel from the context and adds it to the cancellation set.
We have two different rules for right and left cancellation for the channel $a$ in the contexts $\Gamma$ and $\Delta$, respectively.
The channel propagation rule states that if a channel $a$ is cancelled, then the process whose prefix is $a$ should also be cancelled.
The prefix of a process is the channel that the process directly communicates with. We list the prefixes of a process below:
\begin{align*}
  \text{prefix}(\send{x}{M}) &= x \\
  \text{prefix}(\recv{x}{K}) &= x \\
  \text{prefix}(\fwd{y}{x}) &= y
\end{align*}
If the process is not included in the above list, then it does not have a prefix channel.
Cancelling a process is achieved by replacing the process with a process that cancels all the channels in the context. 
\begin{figure}[H]
  \begin{alignat}{2}
    \label{cancelR} \textsc{[cancel-r]} & ~ 
    \Braket{
      \begin{array}{l}
        \procObj{\Gamma}{a : A, \Delta}{\Omega}{\cancel{a}; P}
      \end{array}
      ; \cancelSet
    } \tag*{} \\ ~ \longrightarrow & ~ 
    \Braket{
      \begin{array}{l}
        \procObj{\Gamma}{\Delta}{\Omega}{P}
      \end{array}
      ; \cancelSet \cup \{a\}
    } \tag*{} \\
    \label{cancelL} \textsc{[cancel-l]} & ~ 
    \Braket{
      \begin{array}{l}
        \procObj{\Gamma, a : A}{\Delta}{\Omega}{\cancel{a}; P}
      \end{array}
      ; \cancelSet
    } \tag*{} \\ ~ \longrightarrow & ~ 
    \Braket{
      \begin{array}{l}
        \procObj{\Gamma}{\Delta}{\Omega}{P}
      \end{array}
      ; \cancelSet \cup \{a\}
    } \tag*{} \\
    \label{cancel-prop-r} \textsc{[cancel-prop-r]} & ~ 
    \Braket{
      \begin{array}{l}
        \procObj{\Gamma}{a : A, \Delta}{\Omega}{P}\\
        \text{prefix}(P) = a
      \end{array}
      ; \cancelSet \cup \{a\}
    } \tag*{} \\ ~ \longrightarrow & ~ 
    \Braket{
      \begin{array}{l}
        \procObj{\Gamma}{\Delta}{\Omega}{\cancel{\Gamma}; \cancel{\Delta}} \\
      \end{array}
      ; \cancelSet \cup \{a\}
    } \tag*{} \\
    \label{cancel-prop-l} \textsc{[cancel-prop-l]} & ~ 
    \Braket{
      \begin{array}{l}
        \procObj{\Gamma, a : A}{\Delta}{\Omega}{P} \\
        \text{prefix}(P) = a
      \end{array}
      ; \cancelSet \cup \{a\}
    } \tag*{} \\ ~ \longrightarrow & ~ 
    \Braket{
      \begin{array}{l}
        \procObj{\Gamma}{\Delta}{\Omega}{\cancel{\Gamma}; \cancel{\Delta}}
      \end{array}
      ; \cancelSet \cup \{a\}
    } \tag*{}
  \end{alignat}
  \raggedleft
  \caption{Cancellation reductions of configuration}
  \label{fig:cancelreduction}
\end{figure}
Lastly, we examine the exception reductions in \cref{fig:exnreduction}. 
The \stepref{try-catch}{try-catch} rule spawns two processes, very similar to \stepref{spawn}{spawn}. 
Additionally, it creates another channel $a$ of type \texttt{exn} to serve as the exception handling context for $P$. 
The exception handling process $Q$ uses channel $a$ to wait for exception activation and channel $c$ to communicate with process $P$.
When a process raises an exception, we activate the exception handling by creating a new process object that sends a label \texttt{act} through channel $a$. 
Similarly, when a process finishes without any exceptions and there is an exception handling channel, we send a label \texttt{sil} through channel $a$ to terminate the exception handling process.
\begin{figure}[H]
  \begin{alignat}{2}
    \label{try-catch} \textsc{[try-catch]} & ~ 
    \Braket{
      \begin{array}{l}
        \procObj{\Gamma}{\Delta}{\Omega}{\trycatch{P}{Q}{y}}
      \end{array}
      ; \cancelSet
    } \tag*{} \\ ~ \longrightarrow & ~ 
    \Braket{
      \begin{array}{l}
        \procObj{\Gamma_1}{\Delta_1, c : A}{a : \text{exn}}{P(c)} \\
        \procObj{\Gamma_2, a : \text{exn}, c : A}{\Delta_2}{\Omega}{\text{erecv}\ a\ Q(c)}
      \end{array}
      ; \cancelSet
    } \tag*{} \\
    \label{activation} \textsc{[activate]} & ~ 
    \Braket{
      \begin{array}{l}
        \procObj{\Gamma}{\Delta}{a : \text{exn}}{\craise{P}}
      \end{array}
      ; \cancelSet
    } \tag*{} \\ ~ \longrightarrow & ~ 
    \Braket{
      \begin{array}{l}
        \procObj{\Gamma}{\Delta}{\cdot}{P} \\
        \procObj{\cdot}{a : \text{exn}}{\cdot}{\send{a}{\text{act}}; \send{a}{()}}
      \end{array}
      ; \cancelSet
    } \tag*{} \\
    \label{silence} \textsc{[silent]} & ~ 
    \Braket{
      \begin{array}{l}
        \procObj{\cdot}{\cdot}{a : \text{exn}}{\cdot}
      \end{array}
      ; \cancelSet
    } \tag*{} \\ ~ \longrightarrow & ~ 
    \Braket{
      \begin{array}{l}
        \procObj{\cdot}{a : \text{exn}}{\cdot}{\send{a}{\text{sil}}; \send{a}{()}}
      \end{array}
      ; \cancelSet
    } \tag*{}
  \end{alignat}
  \raggedleft
  \caption{Exception reductions of configuration}
  \label{fig:exnreduction}
\end{figure}
\newpage
\section{Safety theorems}
To ensure the safety of the system, we first need to show the typing of the configuration is preserved as the computation proceeds.
Such property is stated in \cref{thm:preservation}.
\begin{theorem}[Session Fidelity]\label{thm:preservation}
  Given a state $\langle \config, \cancelSet \rangle$, if $\Phi \vdash \config :: \Phi'$ for some $\Phi, \Phi'$
  and $\langle \config, \cancelSet \rangle \longrightarrow \langle \config', \cancelSet' \rangle$,
  then $\Phi \vdash \config' :: \Phi'$.
\end{theorem}
The proof of the theorem is casing over the forms of reduction. 
We will show a few interesting cases to demonstrate how proof proceeds.
\begin{proof}
  We induct on the forms of reduction.
  \begin{itemize}
    \item [\stepref{spawn}{spawn}] In this case, $\config = (\config_L, \procObj{\Gamma}{\Delta}{\Omega}{\spawn{P}{Q}{x}}, \config_R)$ for some $\config_L$ and $\config_R$. 
    Moreover, we assume the following typing judgments hold.
    \begin{align*}
      \Phi & \vdash \config_L :: \Phi_L \\
      \Phi_L & \vdash \procObj{\Gamma}{\Delta}{\Omega}{\spawn{P}{Q}{x}} :: \Phi_R\\
      \Phi_R & \vdash \config_R :: \Phi'
    \end{align*}
    We can split the context $\Gamma$ and $\Delta$ into $\Gamma_1, \Gamma_2$ and $\Delta_1, \Delta_2$ based on the condition given in the reduction rule
    such that we can reconstruct the typing judgment for the configuration successfully.
    By the reduction rule, we know
    \begin{align*}
      \config' &= \config_L, \procObj{\Gamma_1}{a : A, \Delta}{\cdot}{P(a)}, \procObj{\Gamma_2, a : A}{\Delta_2}{\Omega}{Q(a)}, \config_R \\
      \cancelSet' &= \cancelSet
    \end{align*}
    where $a$ is a globally fresh channel.
    To build the typing judgment for the new state, we apply inversion to the typing 
    \[
      \Phi_L \vdash \procObj{\Gamma}{\Delta}{\Omega}{\spawn{P}{Q}{x}} :: \Phi_R
    \]
    We find that for some $\Phi_L'$ and $A$, using the new channel $a$, we must have
    \begin{align*}
      \Phi_L &= (\Phi_L', \Gamma_1, \Gamma_2) \\
      \Gamma_1 & \vdash P(a) :: \Delta_1, a : A; \cdot \\
      \Gamma_2, a : A & \vdash Q(a) :: \Delta_2; \Omega \\
      \Phi_R &= (\Phi_L', \Delta_1, \Delta_2, \Omega)
    \end{align*}
    Now we can construct a typing derivation for $\config'$
    \begin{align*}
      \Phi & \vdash \config_L :: \Phi_L \\
      \Phi_L &= (\Phi_L', \Gamma_1, \Gamma_2) \\
      \Phi_L', \Gamma_1, \Gamma_2 & \vdash \procObj{\Gamma_1}{a : A, \Delta}{\cdot}{P(a)} :: (\Phi_L', \Gamma_2, \Delta_1, a : A) \\
      \Phi_L', \Gamma_2, \Delta_1, a : A & \vdash \procObj{\Gamma_2, a : A}{\Delta_2}{\Omega}{Q(a)} :: (\Phi_L', \Delta_1, \Delta_2, \Omega) \\
      \Phi_R &= (\Phi_L', \Delta_1, \Delta_2, \Omega) \\
      \Phi_L & \vdash \config_R :: \Phi'
    \end{align*}
    This concludes this case of type preservation.
  \item [\stepref{cancelL}{cancel-l}] In this case, $\config = (\config_L, \procObj{\Gamma, a : A}{\Delta}{\Omega}{\cancel{a}; P}, \config_R)$.
    We assume the following typing judgments hold.
    \begin{align*}
      \Phi & \vdash \config_L :: \Phi_L \\
      \Phi_L & \vdash \procObj{\Gamma, a : A}{\Delta}{\Omega}{\cancel{a}; P} :: \Phi_R \\
      \Phi_R & \vdash \config_R :: \Phi'
    \end{align*}
    By the reduction rule, we know
    \begin{align*}
      \config' &= \config_L, \procObj{\Gamma}{\Delta}{\Omega}{P}, \config_R \\
      \cancelSet' &= \cancelSet \cup \{a\}
    \end{align*}
    We can apply inversion to the typing judgment
    \[
      \Phi_L \vdash \procObj{\Gamma, a : A}{\Delta}{\Omega}{\cancel{a}; P} :: \Phi_R
    \]
    to find that for some $\Phi_L'$, we must have
    \begin{align*}
      \Phi_L & = (\Phi_L', \Gamma) \\
      \Gamma & \vdash P :: \Delta; \Omega \\
      \Phi_R & = (\Phi_L', \Delta, \Omega)
    \end{align*}
    Now we can construct a typing derivation for $\config'$
    \begin{align*}
      \Phi & \vdash \config_L :: \Phi_L \\
      \Phi_L & = (\Phi_L', \Gamma) \\
      \Phi_L', \Gamma & \vdash \procObj{\Gamma}{\Delta}{\Omega}{P} :: (\Phi_L', \Delta, \Omega) \\
      \Phi_R & = (\Phi_L', \Delta, \Omega) \\
      \Phi_R & \vdash \config_R :: \Phi'
    \end{align*}
    This concludes this case of type preservation.
  \end{itemize}
\item [\stepref{silence}{silent}] In this case, $\config = (\config_L, \procObj{\cdot}{\cdot}{a : \text{exn}}{\cdot}, \config_R)$.
  We assume the following typing judgments hold.
  \begin{align*}
    \Phi & \vdash \config_L :: \Phi_L \\
    \Phi_L & \vdash \procObj{\cdot}{\cdot}{a : \text{exn}}{\cdot} :: \Phi_R \\
    \Phi_R & \vdash \config_R :: \Phi'
  \end{align*}
  Applying the inversion, we must have $\Phi_R = \Phi_L, a : \text{exn}$. By the reduction rule, we know
  \begin{align*}
    \config' &= \config_L, \procObj{\cdot}{a : \text{exn}}{\cdot}{\send{a}{\text{sil}}; \send{a}{()}}, \config_R \\
    \cancelSet' &= \cancelSet
  \end{align*}
  We can construct a typing derivation for $\config'$ as
  \begin{align*}
    \Phi & \vdash \config_L :: \Phi_L \\
    \Phi_L & \vdash \procObj{\cdot}{a : \text{exn}}{\cdot}{\send{a}{\text{sil}}; \send{a}{()}} :: \Phi_L, a : \text{exn} \\
    \Phi_R & = \Phi_L, a : \text{exn} \\
    \Phi_R & \vdash \config_R :: \Phi'
  \end{align*}
  This concludes this case of type preservation.
\end{proof}
Showing every reduction sequence terminates is not possible in our system because of recursion. 
For instance, a process \texttt{foo} can call itself such that the execution will never terminate.
However, we are able to show that well-typed configurations never get stuck.
In other words, a configuration is either \textit{final}, which means all process objects attempt to communicate along an external channel,
or it can reduce to another configuration. We formalize this property in \cref{thm:progress}.
\begin{theorem}[Deadlock Freedom]\label{thm:progress}
  Given a state $\langle \config; \cancelSet \rangle$ such that $\cdot \vdash \config :: \Phi$, then either $\config$ is final, or 
  $\langle \config; \cancelSet \rangle \longrightarrow \langle \config'; \cancelSet' \rangle$ for some $\config', \cancelSet'$.
\end{theorem}
We require the configuration does not take any input channels. 
Otherwise, the configuration may get stuck because the messages from the input channel may not be available.
The collection of external channels is represented by $\Phi$. Such channels have only one endpoint.
In other words, if $\config$ satisfies $\cdot \vdash \config :: \Phi$, then $\config$ is a closed configuration because it does not depend on any channels.
\begin{proof}
  We prove this theorem by induction on the structure of the configuration, right to left.
  Since the typing of the configuration requires some ordering, a right to left induction provides useful induction hypothesis.
  If $\config = \cdot$, then $\config$ is trivially final and the theorem holds.
  Now we assume the followings: 
  \begin{align*}
    \config &= (\config_L, \procObj{\Gamma}{\Delta}{\Omega}{P}) \\
    \cdot & \vdash \config_L :: (\Phi', \Gamma) \\
    \Phi', \Gamma & \vdash \procObj{\Gamma}{\Delta}{\Omega}{P} :: (\Phi', \Delta) \\
    \Phi & = (\Phi, \Delta) \\
    \cdot & \vdash \config :: \Phi
  \end{align*}
  for a process object $\procObj{\Gamma}{\Delta}{\Omega}{P}$ and $\Phi, \Phi'$. By induction hypothesis,
  we know that $\config_L$ is either final or can reduce to another configuration $\config_L'$ with some cancelled set $\cancelSet'$.
  If it reduces to $\langle \config_L'; \cancelSet' \rangle$, then $\langle \config; \cancelSet \rangle \longrightarrow 
  \langle (\config_L', \procObj{\Gamma}{\Delta}{\Omega}{P}); \cancelSet' \rangle$.
  
  Now assume $\config_L$ is final, we distinguish the cases by the structure of process $P$.
  \begin{itemize}
    \item [\ruleref{cut}] In this case, $P = \spawn{P_1}{P_2}{x}$. By reduction, we know 
    $\langle \config; \cancelSet \rangle \longrightarrow
    \langle (\config_L, \procObj{\Gamma_1}{a : A, \Delta_1}{\cdot}{P_1(a)}, \procObj{\Gamma_2, a : A}{\Delta_2}{\Omega}{P_2(a)}); \cancelSet \rangle$
    with a proper split of the context ensured by the condition.
    \item [\ruleref{weakenL}] In this case $P = \cancel{a}; P'$ and $\Gamma = \Gamma', a : A$. 
    For simplicity, we assume $\config_L$ is final.
    By reduction, we know $\langle \config; \cancelSet \rangle \longrightarrow \langle (\config_L, \procObj{\Gamma'}{\Delta}{\Omega}{P'}); \cancelSet \cup \{a\} \rangle$.
  \end{itemize}
\end{proof}
\chapter{Interpreter}
Experimenting with the proposed type system, we implement a simple interpreter in OCaml. 
We name the source language EPass, an abbreviation for Exceptional Message Passing. 
We don't have a target language; instead, we simulate the execution in OCaml and make observations that output to the console screen. 
There are four main phases in the interpreter: parsing, elaboration, type checking, and runtime simulation.
A complete implementation of the interpreter can be found \href{https://github.com/cekington/ePass}{here}\footnote{https://github.com/cekington/ePass}.
\section{Grammar} 
We present the grammar of the EPass language in \cref{sec:grammar}. There are a few remarks about the grammar.
\begin{itemize}
  \item We use \texttt{type t = } $\ldots$ for type definition and \texttt{proc p} $(\ldots)\ [\ldots]$ \texttt{=} $\ldots$ for process definition.
  \texttt{exec} $p$ executes a closed process, a process without any input channels, and prints out the observation of the external channels. 
  \item We keep $\multimap$ as the linear implication in our language. Although we do not include it in our system, we have shown $A \multimap B$ can be derived in our system.
  Thus, $A \multimap B$ is viewed as a syntactic sugar that is elaborated to $A^\bot \pare B$.
  We do not include $\boldsymbol{\bot}$, since we can derive it by putting $\textbf{1}$ in the other side of the context.
  \item There is not a suitable Unicode character to represent $\pare$. We use @ to represent the multiplicative disjunction.
  \item We modify the try-catch process such that creating a new channel is not necessary. 
  This can be used when the main process and the exception handling process are independent from each other.
  Therefore, $\trycatch{P}{Q}{y}$ and $\textbf{try}\ P \textbf{ catch } Q$ are both valid try-catch processes.
  \item We distinguish identitiers and labels by putting a ' character in front of labels. So the type \texttt{nat} looks like
  \[
    \texttt{nat} \triangleq \oplus\{\text{'zero} : 1 , \text{'succ} : \texttt{nat}\}
  \]
\end{itemize}
As checked by Menhir, a LR$(1)$ parser generator for OCaml, there are no ambiguity in the grammar.
So every source code that follows the grammar can be parsed into the external language properly.
\section{Elaboration}
During the elaboration, we transform the external language into internal language.
\begin{itemize}
  \item We first remove the recursive definitions for types in the external language, which means types have at most one layer.
  This helps to simplify comparing the equality of two types. When we compare two types, we need to compare the outermost layer,
  and, if necessary, we can always expand the type by the newly created identity.

  For example, type definitions of \texttt{nat} and \texttt{list} in the external language 
  \lstinputlisting{code/elab-before.eps}
  will be elaborated to the internal language as
  \lstinputlisting{code/elab-after.eps}
  Besides type elaboration, we also remove the usage of linear implication and distinguish between allocated channels and channel variables.
  Before executing any processes, all the channels should be variables.
  \item After elaboration, we ensure that every definition is well-formed by checking $\Sigma_\text{decl} \vdash \Sigma_\text{defn}$. 
  We extract the declarations by scanning the whole program and build the definitions during the elaboration. 
  Type checking errors are reported for any ill-defined processes or types. 
  Additionally, some syntax that may confuse the runtime semantics is also rejected. 
  For instance, executing open processes and having duplicate labels in either type definition or branching continuation are ruled out.
\end{itemize}
\section{Runtime simulation}
The type checking phase for the interpreter follows the static semantics described in \cref{fig:static}. 
We don't have type inference for channels since the grammar enforces type annotations for every channel variable. 
The runtime simulation essentially follows the reduction rules we discussed before. 
However, we'd like to make a few remarks on how observations of external channels are made during the reduction.

First, we will demonstrate the reason why we need to make observations. Consider the following example of two processes $P_1$ and $P_2$ where $a$ is an external channel and $P$ is some process.
\begin{align*}
  P_1 & \triangleq \send{a}{k}; \send{b}{()}\\
  P_2 & \triangleq \recv{b}{(() \Rightarrow P)}
\end{align*}
According to the definition of external channels, channel $a$ has only one endpoint which occurs in process $P_1$. 
Therefore, this configuration cannot be further reduced because the interaction between $P_1$ and $P_2$ via channel $b$ is blocked by channel $a$. 
Considering this as a final configuration in runtime isn't appropriate because process $P$ may have other effects that are not observed. 
Thus, we need to make observations when the reduction of the configuration gets stuck. In other words, 
the final configuration in the implementation must be an empty configuration.

We illustrate the output of the program with the following example process that returns the addition of two natural numbers. 
The type definition can refer to earlier code.
\lstinputlisting{code/add.eps}
The output has the following form:
\begin{minted}{text}
  Typecheck successful                  
  Executing process add_test_1:
  #0 -> 'succ.'succ.'succ.'zero.()
\end{minted}
Executing process \texttt{add\_test\_1} will generate a fresh variable $\# 0$ for the external channel \texttt{n}. 
The rest represents the message sequence that is sent through the channel. 
A message sequence is a sequence of observed messages separated by dots, which can be a channel $\# i$, 
a label $'l$, a unit $()$, or a waiting $-$. If a channel is in one of the message sequences, 
then it must have its own sequence. A channel sequence ends with either a unit, a waiting, or a cancellation.

A waiting label is used for an external channel that has a $\textbf{recv}$ process which cannot proceed. 
In the above example, the message sequence \texttt{'succ.'succ.'succ.'zero.()} for channel $\# 0$ represents the natural number $3$. 
In the remainder of this chapter, we'll go through a few examples to see how cancellation and exceptions work.
\section{Cancellation example}
We first demonstrate how to drop resources in the example of returning a length of a list.
\lstinputlisting{code/length.eps}
The \texttt{'nil} case is straightforward, where we send $0$ through the channel \texttt{len}.
In the \texttt{'cons} case, \texttt{l} has type \texttt{nat * list}.
While calculating the length, we do not care the element stored in the list.
Therefore, we cancel the channel \texttt{x} and recursively call the process.

Since \texttt{x} is not an external channel in the above example, we cannot see how it is cancelled by observation.
Below is an example that simulates a choice of output. 
We first demonstrate how to drop resources in the example of returning a length of a list.
\lstinputlisting{code/choice.eps}
Since we know the output forms disjunction, we know exactly only one of the \texttt{left} and \texttt{right}
will provide an output. 
Which channel provides the output is decided by whether channel $x$ is \texttt{'true} or \texttt{'false}.
Processes \texttt{choice\_true} and \texttt{choice\_false} tests the \texttt{choice} process.
We present the output of the program below.
\begin{minted}{text}
  Typecheck successful                  
  Executing process choice_true:
  #1 -> cancelled
  #0 -> ()

  Executing process choice_false:
  #1 -> ()
  #0 -> cancelled
\end{minted}
As we can see, in \texttt{choice\_true} process, the \texttt{left} channel $(\# 0)$ receives a unit and the \texttt{right} channel $(\# 1)$ is cancelled.
The output is reversed in \texttt{choice\_false} process, which matches with the expected behavior.
\section{Exception example}
The next example demonstrates how exceptions can be raised and handled. 
The subtraction of \texttt{n1} and \texttt{n2} in natural numbers is not defined if 
\texttt{n2} is bigger than \texttt{n1}. We deal such case by raising an exception and dropping all the unused resources.
\lstinputlisting{code/subtract.eps}
We provide a wrapper process \texttt{wrap\_subtract} to invoke the \texttt{subtract} process, 
as we don't allow exceptions without any handling process. 
Since the process is for example usage, we don't perform any significant action in the \texttt{catch} branch. 
Instead, we simply return $0$ from another external channel \texttt{n\_exn}.

Information can also be exchanged between the main process and the exception handling process by creating a new channel. 
A comprehensive example will be zipping two lists of different length.
The first attempt to call the process zip will raise an exception and pass the difference in lengths of the lists to the second attempt, 
which handles the exception. The second attempt can then adjust for the length difference and reattempt zipping the remaining parts of the lists.
Such code can be found in \cref{sec:exnzip}.
\chapter{Other features}
In this chapter, we delve into advanced features and remove some constraints in the system to enhance the language's 
capabilities in various situations. We study uncaught exceptions and non-exhaustive matching in our system. 
To accommodate these changes, we revisit the typing judgment and the reduction rules. Moreover, we restate the safety theorem to align with the new system. 
Related work and future plans are also included in the last part of this chapter.
\section{Uncaught exception} \label{sec:uncaught}
In most programming languages, uncaught exceptions cause runtime crashes and are reported from the top level. For example, 
the following expression
\begin{minted}{ocaml}
  let x = 1 / 0 in
  x + 1  
\end{minted}
aborts the program and print the following information into console.
\begin{minted}{text}
  Uncaught exception:                   
    
  Division_by_zero

  Raised at ... in file "...", line ..., characters ...
  Called from ... in file "...", line ..., characters ...
\end{minted}
Such behavior is prohibited in our system, since we require every exception to be caught by a process.
Otherwise, the program fails at the typing checking phase. However, we can relax this constraint by allowing uncaught exceptions.
We modify the \ruleref{raise} rule.
\begin{rules}
  \defrule[raise'][raise']{
    \judge{\Gamma}{P}{\Delta}{\cdot}
  }{\judge{\Gamma}{\craise{P}}{\Delta}{\Omega}}
\end{rules}
We relax the constraint that $\Omega$ must be a singleton set. In \ruleref{raise'} rule, $\Omega$ can be either an empty set or a singleton set.
The premise does not change since $\craise{P}$ uses the exception channel no matter whether it is in $\Omega$ or not.
A key observation is that under such relaxation, judgment $\judge{\Gamma}{P}{\Delta}{x : \text{exn}}$ is provable if and only if
$\judge{\Gamma}{P}{\Delta}{\cdot}$. Thus, it seems that the $\Omega$ context is useless and can be omitted in the typing judgment.
However, we can utilize $\Omega$ during the type checking phase and output a warning message
if an exception does not have a direct handling process. For instance, the following code 
\begin{lstlisting}
proc foo (x : 1) [] = 
  raise (cancel x)
\end{lstlisting}
will output the following message to the console.
\begin{minted}{text}
  Warning: In process foo, raise (cancel x) does not have 
  a corresponding exceptional handler
\end{minted}
However, the warning message is conservative in some sense. For example,
if another process \texttt{bar} calls the process \texttt{foo}. No matter whether \texttt{bar} catches the exception or not,  
the warning message still prints to the console. Only handling exceptions directly like
\begin{lstlisting}
proc foo' (x : 1, y : 1) [] =
  try raise (cancel x) catch send y ()
\end{lstlisting}
will not produce the warning message.

We adapt the same industry standard for uncaught exceptions. If an exception is not caught by any process,
the program will abort. We define an error configuration $\Lambda$ in \cref{fig:abortcfg} to indicate that the program is terminated unexpectedly.
\begin{figure}[H]
  \centering
  \begin{tabular}{r r r l l}
    Configuration & $\config$ & $::=$ & $\ldots$ &  \\
    & & $\mid$ & $\Lambda$ & error configuration
   \end{tabular}
   \begin{rules}
    \defrule[error][error]{}{\Phi \vdash \Lambda :: \Phi'}
   \end{rules}
   \vspace*{-1cm}
   \begin{alignat}{4}
    \label{uncaught} \textsc{[uncaught]} & ~ 
    \Braket{
      \begin{array}{l}
        \procObj{\Gamma}{\Delta}{\cdot}{\craise{P}}
      \end{array}
      ; \cancelSet
    } & ~ \longrightarrow & ~ 
    \Braket{
      \begin{array}{l}
        \Lambda
      \end{array}
      ; \cancelSet
    } \tag*{}
  \end{alignat}
  \caption{Extended syntax, typing judgment, and reduction of the configuration}
  \label{fig:abortcfg}
\end{figure}
The typing judgment for the error configuration does not matter. Therefore, $\Lambda$ is well-typed for any input context $\Phi$ and output context $\Phi'$.
We add a new rule \stepref{uncaught}{uncaught}, which is another case of the \stepref{activation}{activate} rule where $\Omega$ is empty.
When an exception is raised with no handling channels, the configuration steps to the error configuration $\Lambda$ directly.
This avoids the problem of concurrent top-level exceptions where it is not clear which exception should be raised.
In our system, the configuration reduces to the only error configuration, and other processes are stopped.

To account for the new reduction rule, we revisit the safety theorems and their proofs.
There is no major change in the proofs of \cref{thm:preservation}, because if a configuration reduces to an error configuration,
we know such configuration is still well-typed by \ruleref{error}. We revise \cref{thm:progress} as follows.
\begin{theorem}[Deadlock Freedom Revisited]
  Given a state $\langle \config; \cancelSet \rangle$ such that $\cdot \vdash \config :: \Phi$, then either
  $\config$ is final, $\langle \config; \cancelSet \rangle \longrightarrow \langle \Lambda; \cancelSet \rangle$ or $\langle \config; \cancelSet \rangle \longrightarrow \langle \config'; \cancelSet' \rangle$ for some $\config', \cancelSet'$.
\end{theorem}
\begin{proof}
  The proof of this theorem extends the original proof by adding the case of uncaught exception.
  \begin{itemize}
    \item [\ruleref{raise'}] In this case $P = \craise{P'}$ and $\Omega = \cdot$.
    By reduction, we know $\langle \config; \cancelSet \rangle \longrightarrow \langle \Lambda; \cancelSet \rangle$.
  \end{itemize}
\end{proof}

In the interpreter, we abort the program simulation when we face with an uncaught exception. For example, in the following tiny example,
\begin{lstlisting}
proc foo (x : 1) [] = 
  raise (cancel x)

proc foo1 (x : 1) [] =
  send x ()

exec foo1

exec foo2
\end{lstlisting}
we get the following message from the console.
\begin{minted}{text}
  Executing process foo1:
  Uncaught exception, process aborted

  Executing process foo2:
  #0 -> ()
\end{minted}
It is worth noting that execution of processes are independent of each other, thus a crash in \texttt{foo1} does not affect 
the execution of \texttt{foo2}. The next feature builds on the idea of uncaught exceptions.

\section{Non-exhaustive match}\label{sec:nonexhaust}
Pattern matching is commonly used for matching on algebraic data types in functional programming languages. The label message reduction
in our system resembles pattern matching. For instance, when receiving messages from a channel of type \texttt{nat},
we need to provide a branch for each label in the type definition. Currently, we require that every label must have its own branch
as restricted by the \ruleref{orL} and \ruleref{withR} rules.
Non-exhaustive matching is a common warning or error in most programming languages.
Such matching will halt program execution if the expression does not match any of the branches.
A good programming practice is to use a wildcard case to handle all remaining, possibly uninteresting cases.
However, it is difficult to achieve with affine typing.
We choose to represent non-exhaustive matching by raising an exception when a label does not have its corresponding branch.
To relax such constraints, we modify the \ruleref{orL} and \ruleref{withR} rules in \cref{fig:nonexhaustive}.
The branching label collection $L'$ is a subset of the original label collection $L$, which means in the original rule, $L' = L$.
\begin{figure}[H]
  \begin{rules}
    \defrule[$\oplus L'$][orL']{
      \judge{\Gamma, x : A_l}{P_l}{\Delta}{\Omega} \\
      L' \subseteq L \\
      (\forall l \in L')
    }{\judge{\Gamma, x : \oplus\{l : A_l\}_{l \in L}}{\recv{x}{(l \Rightarrow P_l)_{l \in L'}}}{\Delta}{\Omega}}
    \\
    \defrule[$\& R'$][withR']{
      \judge{\Gamma}{P_l}{x : A_l, \Delta}{\Omega} \\
      L' \subseteq L \\
      (\forall l \in L')
    }{\judge{\Gamma}{\recv{x}{(l \Rightarrow P_l)_{l \in L'}}}{x : \&\{l : A_l\}_{l \in L}, \Delta}{\Omega}}
  \end{rules}
  \caption{Revisited typing judgment allowing non-exhaustive match}
  \label{fig:nonexhaustive}
\end{figure}
The original reduction rules for labels no longer hold. In \stepref{label-reduction-l}{label-l}
and \stepref{label-reduction-r}{label-r} rules, we need to ensure that $k \in L$.
To handle the possibility of $k \not\in L$, we add two new reduction rules in \cref{fig:nonexreduction}.
The intended behavior is to raise an exception and channel all channels prepared for the \textbf{recv} process.
\begin{figure}[H]
  \begin{alignat}{2}
    \label{label-reduction-r'} \textsc{[label-r']} & ~ 
      \Braket{
        \begin{array}{l}
          \procObj{\Gamma_1}{a : \oplus\{l : A_l\}_{l \in L}, \Delta_1}{\Omega_1}{\send{a}{k}; P} \\
          \procObj{\Gamma_2, a : \oplus\{l : A_l\}_{l \in L}}{\Delta_2}{\Omega_2}{\recv{a}{(l \Rightarrow P_l)_{l \in L}}}
        \end{array}
        (k \not\in L)
        ; \cancelSet
      } \tag*{} \\ ~ \longrightarrow & ~ 
      \Braket{
        \begin{array}{l}
          \procObj{\Gamma_1}{a : A_k, \Delta_1}{\Omega_1}{P} \\
          \procObj{\Gamma_2, a : A_k}{\Delta_2}{\Omega_2}{\cancel{a}, \cancel{\Gamma_2}, \cancel{\Delta_2}}
        \end{array}
        ; \cancelSet
    } \tag*{} \\
    \label{label-reduction-l'} \textsc{[label-l']} & ~ 
      \Braket{
        \begin{array}{l}
          \procObj{\Gamma_1, a : \&\{l : A_l\}_{l \in L}}{\Delta_1}{\Omega_1}{\send{a}{k}; P} \\
          \procObj{\Gamma_2}{a : \&\{l : A_l\}_{l \in L}, \Delta_2}{\Omega_2}{\recv{a}{(l \Rightarrow P_l)_{l \in L}}}
        \end{array}
        (k \not\in L)
        ; \cancelSet
      } \tag*{} \\ ~ \longrightarrow & ~ 
      \Braket{
        \begin{array}{l}
          \procObj{\Gamma_1, a : A_k}{\Delta_1}{\Omega_1}{P} \\
          \procObj{\Gamma_2}{a : A_k, \Delta_2}{\Omega_2}{\cancel{a}, \cancel{\Gamma_2}, \cancel{\Delta_2}}
        \end{array}
        ; \cancelSet
    } \tag*{}
  \end{alignat}
  \raggedleft
  \caption{Extended standard reduction rules of configuration for non-exhaustive match}
  \label{fig:nonexreduction}
\end{figure}
In the runtime simulation, a warning message will be printed to the console any branching continuation misses a label.
A non-exhaustive match, if not handled, will raise an uncaught exception and behaves as described in the previous section.
We demonstrate the non-exhaustive match by the following simple example.
\lstinputlisting{code/unmatch.eps}
The output of the program is as follows.
\begin{minted}{text}
  Warning: In process choose, choice type of channel c
  has non-exaustive match, missing label: 'b
  
  Executing process test_choose1:
  #0 -> 'true.()

  Executing process test_choose2:
  Uncaught exception, process aborted
\end{minted}
A warning message is printed for the process \texttt{choose} because the label \texttt{'b} is missing.
In the process \texttt{test\_choose2}, an uncaught exception is raised because the label send through channel \texttt{c} is \texttt{'b}
and the program is aborted. Such feature can also be used to simulate a process assertion. 
If we are certain that some label should never be sent through a channel, for instance \texttt{'true} or \texttt{'false},
we can omit such cases in branching. We refer to an example of implementing sets using tries in \cref{sec:trie}.
\section{Related work and future work}
We divide the related work into two parts: channel cancellation and exception handling.

Channel cancellation was first proposed to model channel interruption \cite{Mos2014}.
We utilize this idea and refine it as the proof term of explicit weakening rules.
The refinement provides a better way to understand channel cancellation
and connects the relation between processed and sequent proof terms.

In the work of Conversation Calculus, the model provides a simple mechanism by supporting two primitives, \texttt{throw},
and \texttt{try catch}, to handle exceptional situations \cite{Vieira2008}. Compared with our work,
we provide a typed language where exceptions are generalized. For instance,
we can simulate server timeout and client reconnect examples studied by Brun and Dardha \cite{Brun2023}.

Adjoint logic generalizes the usual session types by supporting multiple modes of communication \cite{Klaas2019}.
The current system works under affine logic, which is one layer of adjoint logic.
It remains interesting how exception handling can be generalized to adjoint logic.
In other words, how to pass exceptions from one mode to another mode while both have the correct intended behavior and
maintain the safety of the language. Meanwhile, previous works model data layout using
semi-axiomatic sequent calculus \cite{DeYoung2023}. Memory access errors such as
writing to a freed memory cell or dereferencing an invalid address. In future work,
we plan to study exceptions under a shared memory interpretation.

\appendix
\chapter{EPass and example code} 
\section{EPass grammar} \label{sec:grammar}
\inputminted{text}{code/grammar.txt}
\newpage
\section{List zip} \label{sec:exnzip}
\lstinputlisting{code/listzip.eps}
\newpage
\section{Set as trie} \label{sec:trie}
\lstinputlisting{code/trie.eps}
\backmatter
\printbibliography

\end{document}
